<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    
    <title>SwiftsReader — Academic Reader for ADHD & Dyslexic Minds</title>
    
    <!-- Version: 2.0 - Unified with SwiftsReader design system -->
    <meta name="description" content="SwiftsReader Academic Reader. Fast, focused, unstoppable. Designed specifically for ADHD & dyslexic academics.">
    
    <!-- Typography — unified with SwiftsReader -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    
    <style>
        :root {
            /* SwiftReader Brand — unified with landing page */
            --primary: #00BCD4;           /* cyan */
            --primary-dark: #0097A7;      /* cyan-dark */
            --primary-light: #26C6DA;     /* light cyan */
            --primary-pale: rgba(0, 188, 212, 0.10);
            --accent: #E91E63;            /* magenta */
            --accent-light: rgba(233, 30, 99, 0.12);
            --yellow: #FFC107;
            
            /* Semantic Colors */
            --success: #52C41A;
            --warning: #FFC107;
            --error: #FF4D4F;
            --info: #00BCD4;
            
            /* Neutrals */
            --text-primary: #212121;
            --text-secondary: #616161;
            --text-tertiary: #9E9E9E;
            --text-disabled: #BDBDBD;
            
            /* Backgrounds */
            --bg-canvas: #FAFAFA;
            --bg-surface: #FFFFFF;
            --bg-elevated: #FFFFFF;
            --bg-secondary: #F5F5F5;
            --bg-tertiary: #EEEEEE;
            
            /* Borders */
            --border-light: #E0E0E0;
            --border-medium: #BDBDBD;
            --border-strong: #9E9E9E;
            
            /* Shadows */
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.03);
            --shadow-md: 0 4px 8px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.05);
            --shadow-lg: 0 8px 16px rgba(0, 0, 0, 0.09), 0 4px 8px rgba(0, 0, 0, 0.06);
            --shadow-xl: 0 16px 32px rgba(0, 0, 0, 0.11), 0 8px 16px rgba(0, 0, 0, 0.07);
            
            /* Border Radius */
            --radius-sm: 8px;
            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-xl: 24px;
            --radius-full: 9999px;
            
            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Spacing */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;
            --space-3xl: 64px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg-canvas);
            color: var(--text-primary);
            font-size: 15px;
            line-height: 1.6;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 15% 20%, rgba(0, 188, 212, 0.05) 0%, transparent 40%),
                radial-gradient(circle at 85% 80%, rgba(233, 30, 99, 0.04) 0%, transparent 40%);
            z-index: -1;
            pointer-events: none;
        }

        /* Layout */
        .app-container {
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Focus Mode */
        body.focus-mode .app-header,
        body.focus-mode .library-panel,
        body.focus-mode .document-map {
            display: none !important;
        }

        body.focus-mode .app-main {
            grid-template-columns: 1fr;
            max-width: 100%;
            padding: var(--space-2xl);
        }

        body.focus-mode .reader-area {
            max-width: 900px;
            margin: 0 auto;
        }

        /* Header */
        .app-header {
            background: var(--bg-surface);
            border-bottom: 1px solid var(--border-light);
            padding: var(--space-lg) 0;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(12px);
            background: rgba(250, 250, 250, 0.95);
        }

        .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #00BCD4 0%, #E91E63 50%, #FFC107 100%);
        }

        .header-content {
            max-width: 1600px;
            margin: 0 auto;
            padding: 0 var(--space-xl);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-lg);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }

        .brand-logo-img {
            width: 44px;
            height: 44px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            flex-shrink: 0;
            transition: transform 0.3s;
        }

        .brand:hover .brand-logo-img {
            transform: translateY(-2px);
        }

        .brand-text h1 {
            font-size: 24px;
            font-weight: 800;
            color: var(--text-primary);
            letter-spacing: -0.5px;
            line-height: 1.2;
        }

        .brand-text p {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
            letter-spacing: 0.2px;
        }

        .header-actions {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }

        /* Audio Controls */
        .audio-controls {
            display: flex;
            gap: var(--space-sm);
            align-items: center;
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-secondary);
            border-radius: var(--radius-full);
            border: 1px solid var(--border-light);
        }

        .audio-controls.active {
            background: var(--primary-pale);
            border-color: var(--primary);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .audio-btn {
            width: 36px;
            height: 36px;
            border-radius: var(--radius-full);
            border: none;
            background: var(--bg-surface);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: var(--transition-fast);
            box-shadow: var(--shadow-sm);
        }

        .audio-btn:hover:not(:disabled) {
            background: var(--primary);
            color: white;
            transform: scale(1.05);
            box-shadow: var(--shadow-md);
        }

        .audio-btn:active {
            transform: scale(0.95);
        }

        .audio-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .audio-speed {
            font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-secondary);
            background: var(--bg-surface);
            padding: 4px 10px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            user-select: none;
            transition: var(--transition-fast);
            border: 1px solid var(--border-light);
        }

        .audio-speed:hover {
            background: var(--primary-pale);
            color: var(--primary-dark);
            border-color: var(--primary);
        }

        /* Highlight word being read */
        .reading-word {
            background: rgba(255, 193, 7, 0.35) !important;
            color: var(--text-primary) !important;
            padding: 2px 4px;
            border-radius: 3px;
            animation: wordPulse 0.3s ease-out;
        }

        @keyframes wordPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .header-stats {
            display: flex;
            gap: var(--space-xl);
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace;
        }

        .stat-label {
            font-size: 11px;
            color: var(--text-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            margin-top: var(--space-xs);
        }

        /* Main Content */
        .app-main {
            flex: 1;
            max-width: 1600px;
            width: 100%;
            margin: 0 auto;
            padding: var(--space-2xl) var(--space-xl);
            display: grid;
            grid-template-columns: 280px 1fr 200px;
            gap: var(--space-2xl);
            align-items: start;
        }

        /* Library Panel — sticky wrapper, no overflow here */
        .library-panel {
            position: sticky;
            top: calc(92px + var(--space-2xl));
            height: calc(100vh - 92px - var(--space-2xl) * 2);
            display: flex;
            flex-direction: column;
        }

        /* Inner scroll container — all overflow lives here */
        .library-panel-inner {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
            padding-right: 4px;
            padding-bottom: var(--space-lg);
            min-height: 0; /* critical — lets flexbox shrink below content size */
        }

        .library-panel-inner::-webkit-scrollbar {
            width: 5px;
        }

        .library-panel-inner::-webkit-scrollbar-track {
            background: transparent;
        }

        .library-panel-inner::-webkit-scrollbar-thumb {
            background: var(--border-medium);
            border-radius: var(--radius-full);
        }

        .library-panel-inner::-webkit-scrollbar-thumb:hover {
            background: var(--border-strong);
        }

        .control-panel {
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: var(--shadow-sm);
            position: relative;
            flex-shrink: 0; /* prevent panels from being squashed */
        }

        .control-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--space-md);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: var(--space-sm);
        }

        .panel-icon {
            font-size: 18px;
        }

        .control-group {
            margin-bottom: var(--space-md);
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .control-value {
            font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace;
            color: var(--primary);
            font-weight: 600;
        }

        /* Library List */
        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .library-search {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 13px;
            margin-bottom: var(--space-md);
            transition: var(--transition-fast);
        }

        .library-search:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-pale);
        }

        .library-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .library-item {
            background: var(--bg-secondary);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            cursor: pointer;
            transition: var(--transition-fast);
            position: relative;
        }

        .library-item:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-medium);
            transform: translateX(2px);
        }

        .library-item.active {
            background: var(--primary-pale);
            border-color: var(--primary);
        }

        .library-item-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: var(--space-xs);
        }

        .library-item-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            flex: 1;
            line-height: 1.3;
        }

        .library-item-menu {
            background: none;
            border: none;
            color: var(--text-tertiary);
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            transition: var(--transition-fast);
        }

        .library-item-menu:hover {
            color: var(--text-primary);
        }

        .library-item-meta {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-bottom: var(--space-xs);
        }

        .library-item-tags {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-xs);
            margin-bottom: var(--space-xs);
        }

        .tag {
            padding: 2px 8px;
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .library-item-progress {
            width: 100%;
            height: 4px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            overflow: hidden;
            margin-top: var(--space-sm);
        }

        .library-item-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: var(--radius-full);
            transition: width var(--transition-base);
        }

        /* Sliders */
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: var(--radius-full);
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: var(--shadow-sm);
            transition: var(--transition-fast);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-sm);
            transition: var(--transition-fast);
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }

        /* Buttons */
        .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-sm);
            padding: var(--space-sm) var(--space-md);
            border: none;
            border-radius: var(--radius-md);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
            font-family: inherit;
            white-space: nowrap;
        }

        .button-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.3);
        }

        .button-primary:hover {
            box-shadow: 0 6px 20px rgba(0, 188, 212, 0.4);
            transform: translateY(-2px);
        }

        .button-secondary {
            background: transparent;
            color: var(--text-primary);
            border: 2px solid var(--border-light);
        }

        .button-secondary:hover {
            border-color: var(--primary);
            color: var(--primary);
            background: var(--primary-pale);
        }

        .button-small {
            padding: var(--space-xs) var(--space-sm);
            font-size: 12px;
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: var(--space-sm);
        }

        .button-icon {
            font-size: 16px;
        }

        /* Select Buttons */
        .select-group {
            display: flex;
            flex-wrap: wrap;
            gap: var(--space-sm);
        }

        .select-button {
            flex: 1;
            min-width: 0;
            padding: var(--space-sm);
            background: var(--bg-secondary);
            border: 2px solid var(--border-light);
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 600;
            color: var(--text-secondary);
            cursor: pointer;
            transition: var(--transition-fast);
            text-align: center;
        }

        .select-button:hover {
            border-color: var(--border-medium);
            background: var(--bg-tertiary);
        }

        .select-button.active {
            background: var(--primary-pale);
            border-color: var(--primary);
            color: var(--primary-dark);
        }

        /* Reader Area */
        .reader-container {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }

        .reader-header {
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }

        .reader-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
        }

        .current-paper-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }

        .current-paper-meta {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: var(--space-md);
        }

        .reader-tabs {
            display: flex;
            gap: var(--space-sm);
            border-bottom: 2px solid var(--border-light);
            margin-bottom: var(--space-md);
        }

        .reader-tab {
            padding: var(--space-sm) var(--space-md);
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: var(--transition-fast);
            margin-bottom: -2px;
        }

        .reader-tab:hover {
            color: var(--text-primary);
        }

        .reader-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .reader-area {
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            min-height: 60vh;
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
        }

        .reader-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #00BCD4 0%, #E91E63 50%, #FFC107 100%);
        }

        .reader-display {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-2xl);
        }

        /* ── Dyslexia mode CSS ────────────────────────────────── */
        /* Letter and word spacing applied via CSS vars set by applyDyslexiaMode() */
        body.dyslexia-mode .word-display {
            letter-spacing: var(--dyslexia-letter-spacing, 0px);
            word-spacing:   var(--dyslexia-word-spacing,   0px);
            font-family:    Arial, Verdana, sans-serif; /* sans-serif: evidence-based */
            line-height:    1.6;  /* extra line height reduces crowding */
        }
        /* Narrow column: limits line length to ~60 chars (reduces visual crowding) */
        body.dyslexia-mode .reader-area {
            max-width: 640px;
            margin: 0 auto;
        }
        /* Smooth tint transitions */
        .reader-area, .word-display {
            transition: background-color 0.3s ease;
        }

        .word-display {
            font-size: 48px;
            font-weight: 700;
            line-height: 1.3;
            text-align: center;
            color: var(--text-primary);
            transition: opacity var(--transition-fast);
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.3em;
        }

        .word-display.highlight-first .word:first-child {
            color: var(--accent);
        }

        .word-display.highlight-middle .word {
            color: var(--text-secondary);
        }

        .word-display.highlight-middle .word:first-child {
            color: var(--text-primary);
        }

        .word-display.highlight-all .word {
            color: var(--primary);
        }

        /* Placeholder */
        .reader-placeholder {
            text-align: center;
            color: var(--text-tertiary);
        }

        .reader-placeholder-icon {
            font-size: 64px;
            margin-bottom: var(--space-md);
            opacity: 0.5;
        }

        .reader-placeholder h3 {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-secondary);
            margin-bottom: var(--space-sm);
        }

        .reader-placeholder p {
            font-size: 14px;
            max-width: 400px;
            margin: 0 auto;
        }

        /* Controls Bar */
        .reader-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-md);
            margin-top: var(--space-xl);
            padding-top: var(--space-xl);
            border-top: 1px solid var(--border-light);
        }

        .control-button {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            background: var(--bg-secondary);
            border-radius: var(--radius-full);
            cursor: pointer;
            transition: var(--transition-fast);
            font-size: 20px;
            color: var(--text-primary);
        }

        .control-button:hover {
            background: var(--bg-tertiary);
            transform: scale(1.05);
        }

        .control-button.primary {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(0, 188, 212, 0.3);
            font-size: 24px;
        }

        .control-button.primary:hover {
            box-shadow: 0 6px 20px rgba(0, 188, 212, 0.45);
            transform: scale(1.08);
        }

        /* Progress Bar */
        .progress-container {
            margin-top: var(--space-xl);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-sm);
            font-size: 12px;
            color: var(--text-tertiary);
            font-weight: 600;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            overflow: visible;
            position: relative;
        }

        .progress-bar-inner {
            width: 100%; height: 100%;
            border-radius: var(--radius-full);
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
            border-radius: var(--radius-full);
            transition: width 0.3s ease;
        }

        .progress-section-tick {
            position: absolute;
            top: -2px; bottom: -2px;
            width: 2px;
            background: rgba(255,255,255,0.6);
            pointer-events: none;
        }

        .paper-eta-badge {
            display: inline-flex; align-items: center; gap: 5px;
            background: var(--primary-pale);
            color: var(--primary-dark);
            border: 1px solid rgba(0,188,212,0.25);
            border-radius: 100px;
            padding: 3px 12px;
            font-size: 12px; font-weight: 600;
            margin-top: 6px;
        }

        .section-progress-bar {
            display: flex; gap: 3px;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        .section-pip {
            height: 6px; flex: 1; min-width: 8px; max-width: 32px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            transition: background 0.3s;
        }
        .section-pip.done { background: var(--primary); }
        .section-pip.current { background: var(--accent); }

        .chunk-pause-banner {
            display: none;
            position: absolute;
            bottom: 0; left: 0; right: 0;
            background: linear-gradient(135deg, var(--primary-pale), rgba(233,30,99,0.08));
            border: 1.5px solid rgba(0,188,212,0.3);
            border-radius: var(--radius-lg);
            padding: 20px 24px;
            text-align: center;
            z-index: 10;
        }
        .chunk-pause-banner.visible { display: block; }
        .chunk-pause-title {
            font-size: 18px; font-weight: 700;
            color: var(--text-primary); margin-bottom: 6px;
        }
        .chunk-pause-sub {
            font-size: 13px; color: var(--text-secondary); margin-bottom: 14px;
        }
        .chunk-pause-actions { display: flex; gap: 10px; justify-content: center; }
        .chunk-btn-continue {
            background: var(--primary); color: white;
            border: none; border-radius: var(--radius-md);
            padding: 10px 24px; font-size: 14px; font-weight: 700;
            cursor: pointer;
        }
        .chunk-btn-continue:hover { background: var(--primary-dark); }
        .chunk-btn-skip {
            background: transparent; color: var(--text-secondary);
            border: 1.5px solid var(--border-light);
            border-radius: var(--radius-md);
            padding: 10px 18px; font-size: 14px; cursor: pointer;
        }

        /* ── Page Minimap ────────────────────────────────────────────── */
        /* ── Page Minimap Sidebar ────────────────────────────────────────── */
        #minimapSidebar {
            position: sticky;
            top: calc(92px + var(--space-2xl));
            max-height: calc(100vh - 92px - var(--space-2xl) * 2);
            overflow-y: auto;
        }
        .page-minimap {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-surface);
            border: 1.5px solid var(--border-light);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
        }
        .page-minimap.visible { display: flex; }
        .minimap-header {
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            letter-spacing: 0.5px;
        }
        .minimap-page-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--primary);
        }
        .minimap-thumb-wrap {
            position: relative;
            width: 100%;
            border-radius: 6px;
            overflow: hidden;
            border: 1.5px solid var(--border-light);
            background: #f5f5f5;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            cursor: pointer;
        }
        .minimap-thumb-img {
            width: 100%;
            display: block;
            border-radius: 4px;
        }
        /* Glowing position strip */
        .minimap-position-strip {
            position: absolute;
            left: 0; right: 0;
            height: 18px;
            background: rgba(0, 188, 212, 0.35);
            border-top: 2px solid #00BCD4;
            border-bottom: 2px solid #00BCD4;
            pointer-events: none;
            transition: top 0.25s ease;
            box-shadow: 0 0 8px rgba(0,188,212,0.4);
        }
        /* Page dots row */
        .minimap-page-dots {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .minimap-page-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: var(--border-light);
            cursor: pointer;
            transition: background 0.2s, transform 0.2s;
        }
        .minimap-page-dot.active {
            background: var(--primary);
            transform: scale(1.3);
        }
        .minimap-page-dot.visited {
            background: var(--primary-light);
        }
        /* No thumbnail placeholder */
        .minimap-placeholder {
            width: 100%;
            aspect-ratio: 3/4;
            background: var(--bg-tertiary);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            color: var(--text-tertiary);
        }

        /* Notes Area */
        .notes-area {
            padding: var(--space-lg);
        }

        .notes-section {
            margin-bottom: var(--space-lg);
        }

        .notes-section:last-child {
            margin-bottom: 0;
        }

        .notes-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }

        textarea {
            width: 100%;
            padding: var(--space-md);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 14px;
            color: var(--text-primary);
            background: var(--bg-surface);
            resize: vertical;
            transition: var(--transition-fast);
            min-height: 100px;
        }

        textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-pale);
        }

        input[type="text"] {
            width: 100%;
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-family: inherit;
            font-size: 14px;
            color: var(--text-primary);
            background: var(--bg-surface);
            transition: var(--transition-fast);
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--primary-pale);
        }

        /* Highlights */
        .highlights-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .highlight-item {
            background: linear-gradient(90deg, rgba(0, 188, 212, 0.08) 0%, transparent 100%);
            border-left: 3px solid var(--primary);
            border-radius: var(--radius-sm);
            padding: var(--space-md);
            margin-bottom: var(--space-sm);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .highlight-item:hover {
            background: rgba(0, 188, 212, 0.12);
            transform: translateX(2px);
        }

        .highlight-text {
            font-size: 13px;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            font-style: italic;
        }

        .highlight-meta {
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Document Map */
        .document-map {
            position: sticky;
            top: calc(92px + var(--space-2xl));
            height: calc(100vh - 92px - var(--space-2xl) * 2);
            display: flex;
            flex-direction: column;
            gap: var(--space-md);
        }

        .map-container {
            flex: 1;
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            position: relative;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }

        .map-sections {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .map-section {
            position: absolute;
            left: 0;
            right: 0;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-light);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .map-section:hover {
            background: var(--primary-pale);
        }

        .map-section.current {
            background: var(--primary-light);
        }

        .map-viewport {
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(0, 188, 212, 0.15);
            border: 2px solid var(--primary);
            border-radius: var(--space-xs);
            cursor: grab;
            transition: background var(--transition-fast);
        }

        .map-viewport:active {
            cursor: grabbing;
            background: rgba(0, 188, 212, 0.28);
        }

        .map-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: var(--primary);
            opacity: 0.1;
            pointer-events: none;
        }

        .map-info {
            background: var(--bg-surface);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            box-shadow: var(--shadow-sm);
        }

        .map-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--space-sm) 0;
            font-size: 12px;
        }

        .map-stat:not(:last-child) {
            border-bottom: 1px solid var(--border-light);
        }

        .map-stat-label {
            color: var(--text-tertiary);
            font-weight: 600;
        }

        .map-stat-value {
            color: var(--text-primary);
            font-weight: 700;
            font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace;
        }

        /* Break Reminder */
        .break-reminder {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-surface);
            border: 2px solid var(--primary);
            border-radius: var(--radius-xl);
            padding: var(--space-2xl);
            box-shadow: var(--shadow-xl);
            text-align: center;
            z-index: 3000;
            max-width: 400px;
            animation: slideUp 0.3s ease-out;
        }

        .break-icon {
            font-size: 64px;
            margin-bottom: var(--space-md);
        }

        .break-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
        }

        .break-message {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: var(--space-lg);
        }

        /* Streak Display */
        .streak-badge {
            background: linear-gradient(135deg, var(--yellow) 0%, #FF8F00 100%);
            color: white;
            padding: var(--space-xs) var(--space-md);
            border-radius: var(--radius-full);
            font-size: 12px;
            font-weight: 700;
            display: inline-flex;
            align-items: center;
            gap: var(--space-xs);
            box-shadow: 0 4px 12px rgba(255, 193, 7, 0.35);
        }

        /* Goals Panel */
        .goals-grid {
            display: grid;
            gap: var(--space-md);
        }

        .goal-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
        }

        .goal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-md);
        }

        .goal-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .goal-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--primary);
            font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace;
        }

        .goal-progress-bar {
            width: 100%;
            height: 8px;
            background: var(--bg-tertiary);
            border-radius: var(--radius-full);
            overflow: hidden;
            margin-top: var(--space-sm);
        }

        .goal-progress-fill {
            height: 100%;
            background: var(--success);
            border-radius: var(--radius-full);
            transition: width var(--transition-base);
        }

        .goal-label {
            font-size: 11px;
            color: var(--text-tertiary);
            margin-top: var(--space-xs);
        }

        /* Notifications */
        .notification {
            position: fixed;
            bottom: var(--space-xl);
            right: var(--space-xl);
            background: var(--bg-surface);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-lg);
            padding: var(--space-md) var(--space-lg);
            box-shadow: var(--shadow-xl);
            display: flex;
            align-items: center;
            gap: var(--space-md);
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            animation: slideIn 0.3s ease-out;
            z-index: 1000;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, -40%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%);
                opacity: 1;
            }
        }

        .notification-icon {
            font-size: 20px;
        }

        /* Focus Mode Toggle */
        .focus-toggle {
            position: fixed;
            bottom: var(--space-xl);
            left: var(--space-xl);
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            border: none;
            border-radius: var(--radius-full);
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 188, 212, 0.35);
            transition: var(--transition-base);
            z-index: 999;
        }

        .focus-toggle:hover {
            box-shadow: 0 8px 24px rgba(0, 188, 212, 0.45);
            transform: scale(1.08);
        }

        body.focus-mode .focus-toggle {
            background: linear-gradient(135deg, var(--accent) 0%, #FF5983 100%);
            box-shadow: 0 6px 20px rgba(233, 30, 99, 0.35);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--bg-surface);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: var(--shadow-xl);
            animation: slideUp 0.3s ease-out;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
        }

        .modal-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: var(--text-tertiary);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .modal-close:hover {
            color: var(--text-primary);
        }

        .modal-content {
            margin-bottom: var(--space-lg);
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: var(--space-md);
        }

        .form-group {
            margin-bottom: var(--space-lg);
        }

        .form-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: var(--space-sm);
            display: block;
        }

        /* Responsive */
        @media (max-width: 1400px) {
            .app-main {
                grid-template-columns: 250px 1fr 180px;
            }
        }

        @media (max-width: 1100px) {
            .app-main {
                grid-template-columns: 250px 1fr;
            }
            .document-map {
                display: none;
            }
        }

        @media (max-width: 1024px) {
            .app-main {
                grid-template-columns: 1fr;
            }

            .library-panel {
                position: static;
                max-height: none;
            }

            .header-stats {
                display: none;
            }
        }

        @media (max-width: 640px) {
            .app-header {
                padding: var(--space-md) 0;
            }

            .brand-text h1 {
                font-size: 18px;
            }

            .brand-icon {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .app-main {
                padding: var(--space-lg);
            }

            .reader-area {
                padding: var(--space-lg);
            }

            .word-display {
                font-size: 32px;
            }
        }

        /* Template Badge */
        .template-badge {
            display: inline-block;
            padding: var(--space-xs) var(--space-sm);
            background: var(--info);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Figure/Table Display */
        .figure-display {
            background: var(--bg-surface);
            border: 2px solid var(--border-medium);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            text-align: center;
            max-width: 100%;
        }

        .figure-display img {
            max-width: 100%;
            height: auto;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
            cursor: zoom-in;
        }

        .figure-caption {
            margin-top: var(--space-md);
            font-size: 13px;
            color: var(--text-secondary);
            font-style: italic;
            line-height: 1.5;
        }

        .figure-number {
            font-weight: 700;
            color: var(--primary);
        }

        .table-display {
            background: var(--bg-surface);
            border: 2px solid var(--border-medium);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            overflow-x: auto;
            max-width: 100%;
        }

        .table-display table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .table-display th {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-light) 100%);
            color: white;
            padding: var(--space-sm) var(--space-md);
            text-align: left;
            font-weight: 700;
            border: 1px solid var(--primary-dark);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .table-display td {
            padding: var(--space-sm) var(--space-md);
            border: 1px solid var(--border-medium);
            background: var(--bg-surface);
        }

        .table-display tr:nth-child(even) td {
            background: var(--bg-secondary);
        }

        .table-caption {
            margin-bottom: var(--space-md);
            font-size: 13px;
            color: var(--text-secondary);
            font-style: italic;
        }

        .media-controls {
            display: flex;
            gap: var(--space-sm);
            justify-content: center;
            margin-top: var(--space-md);
        }

        .media-button {
            padding: var(--space-sm) var(--space-md);
            background: var(--bg-secondary);
            border: 1px solid var(--border-medium);
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .media-button:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-strong);
        }

        /* Figures & Tables Tab */
        .media-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: var(--space-lg);
        }

        .media-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-md);
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .media-item:hover {
            border-color: var(--border-medium);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .media-item-preview {
            width: 100%;
            height: 200px;
            background: var(--bg-surface);
            border-radius: var(--radius-md);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: var(--space-md);
            overflow: hidden;
        }

        .media-item-preview img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .media-item-preview.table-preview {
            font-size: 48px;
            color: var(--text-tertiary);
        }

        .media-item-label {
            font-size: 12px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: var(--space-xs);
        }

        .media-item-caption {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        /* Image Zoom Modal */
        .image-zoom-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            cursor: zoom-out;
        }

        .image-zoom-content {
            max-width: 95vw;
            max-height: 95vh;
            object-fit: contain;
        }

        .image-zoom-close {
            position: fixed;
            top: var(--space-xl);
            right: var(--space-xl);
            background: var(--bg-surface);
            border: none;
            width: 48px;
            height: 48px;
            border-radius: var(--radius-full);
            font-size: 24px;
            cursor: pointer;
            box-shadow: var(--shadow-xl);
        }

        /* Pause indicator for figures/tables */
        .pause-indicator {
            font-size: 14px;
            color: var(--accent);
            font-weight: 600;
            margin-top: var(--space-md);
            text-align: center;
        }

        /* Section Summary Display */
        .section-summary-display {
            background: linear-gradient(135deg, var(--primary-pale) 0%, var(--bg-surface) 100%);
            border: 2px solid var(--primary);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            max-width: 800px;
            margin: 0 auto;
        }

        .section-summary-header {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            margin-bottom: var(--space-lg);
            padding-bottom: var(--space-md);
            border-bottom: 2px solid var(--primary);
        }

        .section-summary-icon {
            font-size: 32px;
        }

        .section-summary-title {
            flex: 1;
        }

        .section-summary-title h3 {
            font-size: 18px;
            font-weight: 700;
            color: var(--primary-dark);
            margin-bottom: var(--space-xs);
        }

        .section-summary-title p {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .section-summary-content {
            margin-bottom: var(--space-lg);
        }

        .summary-block {
            background: var(--bg-surface);
            border-left: 4px solid var(--primary-light);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            margin-bottom: var(--space-md);
        }

        .summary-block:last-child {
            margin-bottom: 0;
        }

        .summary-block-title {
            font-size: 12px;
            font-weight: 700;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: var(--space-sm);
        }

        .summary-block-content {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-primary);
        }

        .summary-block-content ul {
            margin: var(--space-sm) 0;
            padding-left: var(--space-lg);
        }

        .summary-block-content li {
            margin-bottom: var(--space-xs);
        }

        .summary-generating {
            text-align: center;
            padding: var(--space-2xl);
            color: var(--text-secondary);
        }

        .summary-spinner {
            display: inline-block;
            width: 40px;
            height: 40px;
            border: 4px solid var(--border-medium);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: var(--space-md);
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .summary-error {
            background: #FFF5F5;
            border: 2px solid var(--error);
            border-radius: var(--radius-md);
            padding: var(--space-md);
            color: var(--error);
            font-size: 13px;
            text-align: center;
        }

        .section-summary-actions {
            display: flex;
            gap: var(--space-sm);
            justify-content: center;
        }

        /* Summaries Tab */
        .summaries-list {
            display: flex;
            flex-direction: column;
            gap: var(--space-lg);
        }

        .summary-item {
            background: var(--bg-secondary);
            border: 1px solid var(--border-light);
            border-radius: var(--radius-lg);
            padding: var(--space-lg);
            transition: var(--transition-fast);
        }

        .summary-item:hover {
            border-color: var(--border-medium);
            box-shadow: var(--shadow-md);
        }

        .summary-item-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: var(--space-md);
            padding-bottom: var(--space-md);
            border-bottom: 1px solid var(--border-light);
        }

        .summary-item-title {
            font-size: 16px;
            font-weight: 700;
            color: var(--primary-dark);
        }

        .summary-item-badge {
            background: var(--primary);
            color: white;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-weight: 700;
        }

        .toggle-summary {
            background: none;
            border: none;
            color: var(--primary);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            padding: var(--space-xs) var(--space-sm);
            border-radius: var(--radius-sm);
            transition: var(--transition-fast);
        }

        .toggle-summary:hover {
            background: var(--primary-pale);
        }

        /* ── Contact Us Modal ───────────────────────────── */
        .contact-modal-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.55);
            z-index: 9999;
            align-items: center;
            justify-content: center;
            padding: 16px;
        }
        .contact-modal-overlay.open {
            display: flex;
        }
        .contact-modal {
            background: #fff;
            border-radius: 20px;
            padding: 40px 36px 32px;
            width: 100%;
            max-width: 480px;
            box-shadow: 0 24px 64px rgba(0,0,0,0.18);
            position: relative;
            animation: contactFadeIn .2s ease;
        }
        @keyframes contactFadeIn {
            from { opacity: 0; transform: translateY(16px); }
            to   { opacity: 1; transform: translateY(0); }
        }
        .contact-modal-close-btn {
            position: absolute;
            top: 16px;
            right: 20px;
            background: none;
            border: none;
            font-size: 22px;
            cursor: pointer;
            color: var(--text-secondary);
            line-height: 1;
            padding: 4px;
        }
        .contact-modal-close-btn:hover { color: var(--text-primary); }
        .contact-modal h2 {
            font-size: 22px;
            font-weight: 800;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        .contact-modal p.contact-sub {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 24px;
        }
        .contact-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 16px;
        }
        .contact-field label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
        }
        .contact-field input,
        .contact-field textarea {
            border: 1.5px solid var(--border-light);
            border-radius: 10px;
            padding: 11px 14px;
            font-size: 14px;
            font-family: inherit;
            color: var(--text-primary);
            background: var(--bg-secondary);
            transition: border-color .15s;
            resize: vertical;
            outline: none;
        }
        .contact-field input:focus,
        .contact-field textarea:focus {
            border-color: var(--primary);
            background: #fff;
        }
        .contact-field textarea { min-height: 110px; }
        .contact-submit-btn {
            width: 100%;
            padding: 13px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(135deg, var(--primary) 0%, #26C6DA 100%);
            color: #fff;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            margin-top: 4px;
            transition: opacity .15s;
        }
        .contact-submit-btn:hover { opacity: .88; }
        .contact-modal-success {
            display: none;
            text-align: center;
            padding: 20px 0 8px;
        }
        .contact-modal-success .success-icon { font-size: 48px; margin-bottom: 12px; }
        .contact-modal-success h3 { font-size: 20px; font-weight: 800; color: var(--text-primary); margin-bottom: 8px; }
        .contact-modal-success p  { font-size: 14px; color: var(--text-secondary); }
    </style>
  <!-- Vercel Analytics -->
  <script defer src="/_vercel/insights/script.js"></script>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <header class="app-header">
            <div class="header-content">
                <div class="brand">
                    <img src="data:image/jpeg;base64,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AKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAjqJ2UIcnAx19KkY4HArxv4qeKzo+nDSbRitzfgjIxlI+5/HpWtOm5ySPPxmKjhqTqzPTNI1mx1mOSexfzEikeIntuQ4OK288E18/wDwSv08i/0s8eXIJVGc5Dggn16ivf8APGKqtT5JcplluL+tYdVe4+iiisD1QooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigApD0paYe/agCjd3UVnbPcSsFSIEsT0wOtfEHiLXJPEOt3OsMSEmfbGDj5YkOFx9a+h/jBrbaZ4b+wREq9+wiyMZCcFvzAx+NfKgIwFUYAxj8BgV9DgaVo89j8i4qxvNJYeJ6X8LtW/svxdbpJ8kd5GYSxPcbio/MAV9hKVx161+e8d1LbzLdxEiSFhIv1Qgj+XSvu3w7qcWsaPaanH925jVsehPUfgeKwx9PVTR6nCeKvSdDsdDzn2paTHT2pa8U/SQooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooATAxionXA47Cn/wioJmwm7OMc/gKnqKXw3PkT4x6wNQ8UiyR8x2MYUjjG98En8sCvKNwxir+t6j/AGlrd/qOcrczuy8D7pPH8qysjGK+6oR5YRjY/nDMK/t8RKfmTlgcc4xz+VfSfwR8QGa0ufDUxObM+ZEeOY3zx+B/zivmZGw2a3PC3iF/DmuWmrICViIRwO8bcMD9Ac+2KnE0lOn5nVlGM+q4mM+h+gHRqcQPXFUrS6juoI7iFg8bgMpHQqRkGrnbFfFNWP6DjJNJrZklFFFIsKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAoopOBQAtFFFADCMVzXim8Gm+HdRvd4jMNvK4Y44IUkdeOtdGenpXi/x2vxZfDnUFB2tcGKNccZ3SKSPxUGuijHmqJHnY+r7LDzmfHkTnykIP3gCPYYyB+ZNL5jbutZ1hOJrRF43oBn6YwKubs8Zr71Rtp2P5t5+ZuRYEjCkZiTjGc8Y9e2KhDDuaDJnoaXLqhH1f8EvFi3+nv4ZumJmsBuhY/wAcByB/3yePpivoAHGK/Obw94guPDWs22tWZO62PzKOjR4IZcdMYJ+h5HIFff2h6rBrWl22q2bAwXCB19RkdPwr5LH0PZyutj9u4dzD29H2Ut0bgOcU+mgYNOryD7YKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAIXOPrXzv8AHX4sz/DKx0f7HzPe3sfmKMEi1iIaXg5wGUEZHIzwQa+hmO1eeor8sf2kvEp174o3dqr7oNHiW0QcY3fK7jjvnAJPPbpXNXqckbo+fzbF/V6N47n6e6ZqFrqunW2pWTh4LmNZEI6FXGRWrXxn+yj8Q11TR5fAWpSE3mkjdbEkZe2fOQPXa31OPYV9l+nH/wBatoT54pnoYPErEUIzWzHDnHavmr9pOVovB+nRZwst/ECPUCNz/MCvpP8Ahx6f0r5h/aawPC2kqOgv1/SNwK9TAq9dHlZ+7YCp6HyFaTiCVXzwTgj17CukMgH3egGc+tcWzqvFb9ndCWHymPzRd/UV+h1afU/nLD1NeU0skUA4qv5rU3zG9a4z07F1WyQAMnjGP89K91+CvjuPS77/AIRfUJALW6YvbsT8qSc5Qn3x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I4zkc4rw/wDZT+An/CwNaTxv4kjI8PadJ+4Rsqbm4QHg4IO1DhuODgA5BIr9b4YYoUVYlCooAUDgAAdAOgr8i4mzu7eEoM8DG4r/AJdwLgUDpTsdqKK/KDwAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAj9qz728trCxmvrlhHDChkdj2RRknj0FXicKe1fJ/wC034+bRNBTwlYvsu9VBEm0jKQKRn6biMfTNd+Dwk8TXjRidVCi601BHxx8RvGE/jnxff68xPkGQx26n+GJBhAPZgN31riKBhcDuMD8AMD9Ka8ixIXY4C81/TeGoQo0o0qfQ/T6dNQioFPUL5LGAtn5yMAfXivOpXZpGdzl3PJ/+tWjf3bXs5lJ+Rfuj07Vn7Q+Wwc+3f0Fbu179C2vvEUDAGMnI4/pXsPwm+Et78Q7qbVNRkNh4Z05WkvLvGF2ICWjjJ74GCewyRggVnfCb4Wat8VfEyaJYkw2UJDXd0BxChByFPQscYHua+wP2n9Y0b4QfB60+HfhWNbM6232RFTqII/mmYk5JLYCknnDHB4FfF5nmcvarB4f43+B4eKxfK/ZQ3Pza8XazZa74ivtQ0yAW9g8m21jx922T5YvckgZJOSc8muY/pS7QoAXoowPYccfTjihRk19tSg4Rt2Jd9AOF55xx0r174K/CfVvi/4xh0K3Bi06DEt9cAZEUI/gB/vNjA7jOeMV514d0DU/FetWXh3QoGnvtSkEcMYHPJwWOOigZJPoDX7c/BT4T6R8JfB9todpiS/kAku5hn97NjBIz0VegA474zXxXEGcrCUeSHxs83F1+SOnU9J8NeH9J8L6PaaFotuttaWSLFHGvYKOCc8kkcknmul2+tNC+lKRivwJtyd5PU+TbvqPxiiiikAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQB//9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKK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qMAAdhitXGPevxrMcdPGVnWmfGYrEOtPmY7GKKKK8o4xjDgCvHfiv4aufHel2fgQbl0/VblG1CRcjFlAfMZARzmSRUjOCCFY17GcYA7UhReuKcJOMk0UnZ3KVnaW9nbxWttGIooVCIgGAqgAAAdhgdK0KQKBn3paRIUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFMVWH3jmn0UAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAj24Fcf401O50TwvqWoWaNJPDC3kooGWkPCAfUkCu0rntciW4iEBGR1P9K1pW50zSnpJH5Eaj8MviP4o1yGwttMkaa4mJLPjG+UgsTjjagyT24r9PPhP8OdO+GPhKz8PWI3yqC9xL3llP3mPtngAdOOK7XRdCt7H/Sdg81hgewrpsCvps1zupjIqltFHpYrGyqrk2QgUDHtTqKK+UPJCiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//1v38ooooAKKKKACiiigAoppOD7U6gAooooAKKKKACiiigAopMijIoAWikyKMigAPSstYzcXDSMPkQ4HvitF+VIXqaERYlCjgCmmO48dKWk3CjIpCFopMijIoAWikyKMigBaKTIoyKAFopMijcKAFopNwo3CgBaKTcKMigBaKKKACiiigAooooAKKKKACiiigAoopOgoAWim7jRuNADqKbuNG6gB1FFFABRTdxo3GgB1FN3GjcaAHUUUUAFFFNLelADqKbuNOHNABRRRQAUUhOKTcaAHUU3caN1ADqKTcKWgAoopOgoAWim7jRuNADqKbuNKDmgBaKKbuNADqKbuNG40AOopu6nUAf//X/fyiiigAooooAKRulLTCTg+1ADM9u1SjpVZj82TU6mgB9FFFABRRRQAUUUUAFJtFLRQA3bRtp1FADdpo2mnUUAN2mjaadRQA3aaNpp1FADdpo2mnUUAN2mjaadRQA3bRtp1FACbRRgUtFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABSHpS0h6UAMpQM0lPHSgBNpptSVHQA5fSnUwdafQAw9aSlPWgdaAF2mjaadRQAUUUUAFR05qbQAU5fSkIxSDjpQBJRRRQA1qbTmptADtppMGn0UAR0oOKUjvTaAJKQ9KRaU9KAGUoGaSnjpQAm00AYp1FABUdSVHQAoGaXaaFp1AEdFKetJQB//9D9/KKKKACiiigBD0qM9KlqMjg+1AEKjJ5qyBimAelSUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFIelLSHpQAylBxSUuDQAE5pKKcD2oAUDFLRRQAw9aSlPWgDNABk0ZNLto20AOoopOgoAaeTSr1ptKDigBx6UynbhTaAHjpS01adQA1qbTmptAElFFFABUdPPSmUAOWlPSkWlPSgBlLk0lKBmgAyacDmk20oGKAFqOpKjoAUHFLupAM0EYoASilBxT6AP/R/fyiiigAooooAKa3WnU0j0oAFp1IOlLQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUh6UtIelADKeOlMp46UAIR6U2pKYRigBQe1OqOpKAGHrQOtB60lAElFR0UASU1vSlHSmHnrQAUuDQOtPoAZg0mMcVJSN0oAZUlR08dKAEam05qbQBJRUdFACk5pKKcBigBQMCg9KWkPSgBlPHSmUUASUVHSjrQA+o6kqOgBy0pGaRadQBHRTiO9NoA//9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigBMCloooAKMZoooATApcYoooATAowKWigBMCjApaKADHakwKWigAxiiiigAooooATApcYoooAMZpMClooATAowKWigAooooAKKKKAEwKMClooATAowKWigApMClooAMYooooAKTApaKAP/2Q==" alt="SwiftsReader" style="width:44px;height:44px;border-radius:10px;box-shadow:0 4px 12px rgba(0,0,0,0.12);object-fit:contain;background:white;flex-shrink:0;">
                    <div class="brand-text">
                        <h1>SwiftsReader</h1>
                        <p>Academic Reader</p>
                    </div>
                </div>
                <div class="header-actions">
                    <div id="streakDisplay" class="streak-badge" style="display: none;">
                        🔥 <span id="streakCount">0</span> day streak
                    </div>
                    <div class="header-stats">
                        <div class="stat">
                            <div class="stat-value" id="headerWpmDisplay">300</div>
                            <div class="stat-label">WPM</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="headerProgressDisplay">0%</div>
                            <div class="stat-label">Progress</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value" id="headerPapersDisplay">0</div>
                            <div class="stat-label">Papers</div>
                        </div>
                    </div>
                    <button class="button button-primary" id="addPaperBtn">
                        <span>+ Add Paper</span>
                    </button>
                    <button class="button" onclick="openContactModal()" aria-label="Contact Us" style="background:transparent;border:1.5px solid var(--border-light);color:var(--text-secondary);border-radius:10px;padding:8px 16px;font-size:13px;font-weight:600;cursor:pointer;transition:border-color .15s,color .15s;" onmouseover="this.style.borderColor='var(--primary)';this.style.color='var(--primary)'" onmouseout="this.style.borderColor='var(--border-light)';this.style.color='var(--text-secondary)'">Contact Us</button>
                    <!-- User account info -->
                    <div id="userInfoBar" style="display:flex;align-items:center;gap:8px;font-size:12px;color:var(--text-secondary);">
                        <span id="userTierBadge" style="padding:3px 10px;border-radius:20px;font-weight:700;font-size:11px;background:var(--primary-pale);color:var(--primary-dark);">FREE</span>
                        <span id="userEmailDisplay" style="max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
                        <button id="upgradeBtn" onclick="openUpgradeModal()" style="display:none;padding:4px 10px;background:var(--primary);color:white;border:none;border-radius:6px;font-size:11px;font-weight:700;cursor:pointer;">Upgrade</button>
                        <button id="logoutBtn" title="Sign out" style="background:none;border:1px solid var(--border-light);border-radius:6px;padding:3px 8px;font-size:11px;cursor:pointer;color:var(--text-secondary);">Sign out</button>
                    </div>
                    <!-- Audio Reader Controls -->
                    <div class="audio-controls" id="audioControls">
                        <button class="audio-btn" id="audioPlayBtn" title="Play Audio">▶️</button>
                        <button class="audio-btn" id="audioPauseBtn" title="Pause Audio" style="display: none;">⏸️</button>
                        <button class="audio-btn" id="audioStopBtn" title="Stop Audio">⏹️</button>
                        <div class="audio-speed" id="audioSpeed" title="Click to change speed">1.0x</div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="app-main">
            <!-- Library Panel -->
            <aside class="library-panel">
              <div class="library-panel-inner">
                <!-- Library -->
                <div class="control-panel">
                    <div class="panel-title">
                        <div style="display: flex; align-items: center; gap: var(--space-sm);">
                            <span class="panel-icon">📚</span>
                            <span>Library</span>
                        </div>
                        <span id="libraryCount" style="font-size: 12px; color: var(--text-tertiary);">0</span>
                    </div>
                    <input type="text" class="library-search" id="librarySearch" placeholder="Search papers...">
                    <div class="library-list" id="libraryList">
                        <p style="text-align: center; color: var(--text-tertiary); font-size: 12px; padding: var(--space-lg);">
                            No papers yet. Click "Add Paper" to get started.
                        </p>
                    </div>
                </div>

                <!-- Reading Settings -->
                <div class="control-panel">
                    <div class="panel-title">
                        <span class="panel-icon">⚡</span>
                        Reading Settings
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Template</span>
                        </div>
                        <div class="select-group" style="display: grid; gap: var(--space-xs);">
                            <button class="select-button active" data-template="custom">Custom</button>
                            <button class="select-button" data-template="skim">Skim (400 WPM)</button>
                            <button class="select-button" data-template="focus">Deep Focus (250 WPM)</button>
                            <button class="select-button" data-template="adhd">ADHD-Friendly</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Words Per Minute</span>
                            <span class="control-value" id="wpmValue">300</span>
                        </div>
                        <input type="range" id="wpmSlider" min="100" max="1000" value="300" step="25">
                    </div>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Chunk Size</span>
                            <span class="control-value" id="chunkValue">1 word</span>
                        </div>
                        <input type="range" id="chunkSlider" min="1" max="5" value="1" step="1">
                    </div>
                    <div class="control-group">
                        <div class="control-label">Break Timer</div>
                        <div class="select-group">
                            <button class="select-button" data-break="0">Off</button>
                            <button class="select-button active" data-break="25">25min</button>
                            <button class="select-button" data-break="45">45min</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">Section-by-Section Mode</div>
                        <div class="select-group">
                            <button class="select-button active" data-chunkmode="false">Off</button>
                            <button class="select-button" data-chunkmode="true">On</button>
                        </div>
                        <div style="font-size:11px;color:var(--text-tertiary);margin-top:4px;line-height:1.4;">Pauses at each section break so you can absorb one chunk at a time</div>
                    </div>
                </div>

                <!-- Appearance -->
                <div class="control-panel">
                    <div class="panel-title">
                        <span class="panel-icon">🎨</span>
                        Appearance
                    </div>
                    <div class="control-group">
                        <div class="control-label">Font Size</div>
                        <div class="select-group">
                            <button class="select-button" data-size="32">S</button>
                            <button class="select-button active" data-size="48">M</button>
                            <button class="select-button" data-size="64">L</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">Font</div>
                        <div class="select-group">
                            <button class="select-button active" data-font="Inter">Sans</button>
                            <button class="select-button" data-font="Georgia, serif">Serif</button>
                            <button class="select-button" data-font="monospace">Mono</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">Dyslexia Mode</div>
                        <div class="select-group">
                            <button class="select-button active" data-dyslexia="false">Off</button>
                            <button class="select-button" data-dyslexia="true">On</button>
                        </div>
                    </div>
                    <!-- Dyslexia sub-controls — shown only when Dyslexia Mode is On -->
                    <div id="dyslexiaControls" style="display:none;">
                        <div class="control-group" style="margin-top:8px;">
                            <div class="control-label" style="font-size:10px;color:var(--text-tertiary);">Background tint</div>
                            <div style="display:flex;gap:6px;flex-wrap:wrap;margin-top:4px;">
                                <button class="tint-btn active" data-tint="none"    title="None"        style="width:22px;height:22px;border-radius:50%;background:#fff;border:2px solid var(--primary);cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="cream"   title="Cream"       style="width:22px;height:22px;border-radius:50%;background:#FEFAE0;border:2px solid transparent;cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="yellow"  title="Pale yellow" style="width:22px;height:22px;border-radius:50%;background:#FFFACD;border:2px solid transparent;cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="blue"    title="Pale blue"   style="width:22px;height:22px;border-radius:50%;background:#E8F4FD;border:2px solid transparent;cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="green"   title="Pale green"  style="width:22px;height:22px;border-radius:50%;background:#F0FBF0;border:2px solid transparent;cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="peach"   title="Peach"       style="width:22px;height:22px;border-radius:50%;background:#FEF0E7;border:2px solid transparent;cursor:pointer;"></button>
                                <button class="tint-btn"        data-tint="lavender" title="Lavender"   style="width:22px;height:22px;border-radius:50%;background:#F3EFFE;border:2px solid transparent;cursor:pointer;"></button>
                            </div>
                        </div>
                        <div class="control-group" style="margin-top:8px;">
                            <div class="control-label" style="font-size:10px;color:var(--text-tertiary);">Letter spacing <span id="letterSpacingVal">+2px</span></div>
                            <input type="range" id="letterSpacingSlider" min="0" max="6" step="1" value="2"
                                style="width:100%;margin-top:4px;accent-color:var(--primary);">
                        </div>
                        <div class="control-group" style="margin-top:8px;">
                            <div class="control-label" style="font-size:10px;color:var(--text-tertiary);">Word spacing <span id="wordSpacingVal">+4px</span></div>
                            <input type="range" id="wordSpacingSlider" min="0" max="12" step="2" value="4"
                                style="width:100%;margin-top:4px;accent-color:var(--primary);">
                        </div>
                        <div class="control-group" style="margin-top:8px;">
                            <div class="control-label" style="font-size:10px;color:var(--text-tertiary);">TTS word highlight</div>
                            <div class="select-group" style="margin-top:4px;">
                                <button class="select-button active" data-ttshighlight="on">On</button>
                                <button class="select-button" data-ttshighlight="off">Off</button>
                            </div>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">Highlight</div>
                        <div class="select-group">
                            <button class="select-button active" data-highlight="none">None</button>
                            <button class="select-button" data-highlight="first">First</button>
                            <button class="select-button" data-highlight="all">All</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <div class="control-label">Theme</div>
                        <div class="select-group">
                            <button class="select-button active" data-theme="light">Light</button>
                            <button class="select-button" data-theme="sepia">Sepia</button>
                            <button class="select-button" data-theme="dark">Dark</button>
                        </div>
                    </div>
                </div>

                <!-- Quick Actions -->
                <div class="control-panel">
                    <div class="panel-title">
                        <span class="panel-icon">⚙️</span>
                        Quick Actions
                    </div>
                    <div class="button-group" style="display: grid; gap: var(--space-sm);">
                        <button class="button button-secondary button-small" id="goalsBtn">
                            <span>📊 Goals</span>
                        </button>
                        <button class="button button-secondary button-small" id="exportAllBtn">
                            <span>💾 Export</span>
                        </button>
                        <button class="button button-secondary button-small" id="shortcutsBtn">
                            <span>⌨️ Keys</span>
                        </button>
                    </div>
                </div>
              </div><!-- /.library-panel-inner -->
            </aside>

            <!-- Reader Container -->
            <section class="reader-container">
                <!-- Reader Header -->
                <div class="reader-header" id="readerHeader" style="display: none;">
                    <div class="current-paper-title" id="currentPaperTitle">No paper selected</div>
                    <div class="current-paper-meta" id="currentPaperMeta"></div>
                    
                    <div class="reader-tabs">
                        <button class="reader-tab active" data-tab="read">📖 Read</button>
                        <button class="reader-tab" data-tab="notes">📝 Notes</button>
                        <button class="reader-tab" data-tab="highlights">✨ Highlights</button>
                        <button class="reader-tab" data-tab="summaries">📋 Summaries</button>
                        <button class="reader-tab" data-tab="media">📊 Figures & Tables</button>
                    </div>
                </div>

                <!-- Tab: Read -->
                <div class="tab-content active" data-tab-content="read">
                    <div class="reader-area">
                        <div class="reader-display">
                            <div class="reader-placeholder">
                                <div class="reader-placeholder-icon">📖</div>
                                <h3>Welcome to SwiftsReader</h3>
                                <p>Add a paper to your library or paste text to begin reading. Designed for academics with ADHD and dyslexia support.</p>
                            </div>
                        </div>

                        <!-- Controls -->
                        <div class="reader-controls">
                            <button class="control-button" id="prevBtn" title="Previous (←)">
                                <span>⏮</span>
                            </button>
                            <button class="control-button primary" id="playBtn" title="Play/Pause (Space)">
                                <span>▶</span>
                            </button>
                            <button class="control-button" id="nextBtn" title="Next (→)">
                                <span>⏭</span>
                            </button>
                            <button class="control-button" id="bookmarkBtn" title="Bookmark (B)">
                                <span>🔖</span>
                            </button>
                            <button class="control-button" id="highlightBtn" title="Highlight (H)">
                                <span>✨</span>
                            </button>
                            <button class="control-button" id="restartBtn" title="Restart from beginning (R)">
                                <span>↩</span>
                            </button>
                        </div>

                        <!-- Progress -->
                        <div class="progress-container" style="position:relative;">
                            <div class="progress-info">
                                <span id="progressText">0 / 0 words</span>
                                <span id="timeRemaining">0:00 remaining</span>
                            </div>
                            <div class="progress-bar" id="progressBarWrap">
                                <div class="progress-bar-inner">
                                    <div class="progress-fill" id="progressFill"></div>
                                </div>
                            </div>
                            <!-- Section pips -->
                            <div class="section-progress-bar" id="sectionPips"></div>
                            <!-- ETA badge shown before reading starts -->
                            <div id="etaBadge" class="paper-eta-badge" style="display:none;">
                                ⏱ <span id="etaBadgeText">~0 min read</span> at your speed
                            </div>
                            <!-- Chunk mode pause banner -->
                            <div class="chunk-pause-banner" id="chunkPauseBanner">
                                <div class="chunk-pause-title" id="chunkPauseTitle">Section complete ✓</div>
                                <div class="chunk-pause-sub" id="chunkPauseSub">Take a breath. Ready for the next section?</div>
                                <div class="chunk-pause-actions">
                                    <button class="chunk-btn-continue" onclick="chunkContinue()">Next Section →</button>
                                    <button class="chunk-btn-skip" onclick="chunkSkip()">Skip to End</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Notes -->
                <div class="tab-content" data-tab-content="notes">
                    <div class="reader-area">
                        <div class="notes-area">
                            <div class="notes-section">
                                <label class="notes-label">Key Findings</label>
                                <textarea id="notesKeyFindings" placeholder="What are the main findings or arguments?"></textarea>
                            </div>
                            <div class="notes-section">
                                <label class="notes-label">Summary</label>
                                <textarea id="notesSummary" placeholder="Summarize the paper in your own words..."></textarea>
                            </div>
                            <div class="notes-section">
                                <label class="notes-label">Relevance to My Research</label>
                                <textarea id="notesRelevance" placeholder="How does this relate to your work?"></textarea>
                            </div>
                            <div class="notes-section">
                                <label class="notes-label">Questions / Follow-up</label>
                                <textarea id="notesQuestions" placeholder="What questions remain? What should you read next?"></textarea>
                            </div>
                            <button class="button button-primary" id="saveNotesBtn" style="width: 100%;">
                                <span>💾 Save Notes</span>
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Tab: Highlights -->
                <div class="tab-content" data-tab-content="highlights">
                    <div class="reader-area">
                        <div class="notes-area">
                            <div class="notes-label" style="margin-bottom: var(--space-md);">
                                Your Highlights
                                <span style="color: var(--text-tertiary); font-weight: normal; margin-left: var(--space-sm);" id="highlightCount">(0)</span>
                            </div>
                            <div class="highlights-list" id="highlightsList">
                                <p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl);">
                                    No highlights yet. Press H or click the highlight button while reading to mark important passages.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Summaries -->
                <div class="tab-content" data-tab-content="summaries">
                    <div class="reader-area">
                        <div class="notes-area">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-md);">
                                <div class="notes-label">
                                    Section Summaries
                                    <span style="color: var(--text-tertiary); font-weight: normal; margin-left: var(--space-sm);" id="summariesCount">(0)</span>
                                </div>
                                <button class="button button-primary button-small" id="generateAllSummariesBtn">
                                    ✨ Generate All Summaries
                                </button>
                            </div>
                            <div class="summaries-list" id="summariesList">
                                <p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl);">
                                    No summaries yet. Click "Generate All Summaries" or summaries will be created automatically as you read through sections.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tab: Figures & Tables -->
                <div class="tab-content" data-tab-content="media">
                    <div class="reader-area">
                        <div class="notes-area">
                            <div class="notes-label" style="margin-bottom: var(--space-md);">
                                Figures & Tables
                                <span style="color: var(--text-tertiary); font-weight: normal; margin-left: var(--space-sm);" id="mediaCount">(0)</span>
                            </div>
                            <div class="media-grid" id="mediaGrid">
                                <p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl); grid-column: 1 / -1;">
                                    No figures or tables detected in this paper.
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Page Minimap Sidebar -->
            <aside class="document-map" id="minimapSidebar" style="display:none;">
                <div class="page-minimap" id="pageMinimap" style="margin-top:0;border:none;padding:0;background:transparent;box-shadow:none;">
                    <div class="minimap-header">
                        <span>📄 Page View</span>
                        <span class="minimap-page-label" id="minimapPageLabel">—</span>
                    </div>
                    <div class="minimap-thumb-wrap" id="minimapThumbWrap">
                        <div class="minimap-placeholder" id="minimapPlaceholder">Open a PDF to see page preview</div>
                        <img class="minimap-thumb-img" id="minimapThumbImg" style="display:none;" alt="Page preview" />
                        <div class="minimap-position-strip" id="minimapStrip" style="display:none;"></div>
                    </div>
                    <div class="minimap-page-dots" id="minimapPageDots"></div>
                    <div style="font-size:10px;color:var(--text-tertiary);text-align:center;margin-top:4px;">Click a dot to jump to page</div>
                </div>
            </aside>
        </main>
    </div>

    <!-- Focus Mode Toggle -->
    <button class="focus-toggle" id="focusToggle" title="Toggle Focus Mode (F)">
        <span>🎯</span>
    </button>

    <script>
        // Configure PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // Configuration
        const ContentType = {
            TEXT: 'text',
            PAUSE: 'pause',
            FIGURE: 'figure',
            TABLE: 'table',
            SECTION_START: 'section_start'
        };

        // Reading Templates
        const ReadingTemplates = {
            custom: { wpm: 300, chunkSize: 1, name: 'Custom' },
            skim: { wpm: 400, chunkSize: 2, name: 'Skim Reading' },
            focus: { wpm: 250, chunkSize: 1, name: 'Deep Focus' },
            adhd: { wpm: 350, chunkSize: 1, name: 'ADHD-Friendly', highlightMode: 'first', fontSize: 56 }
        };

        // State
        let library = [];
        let currentPaperId = null;
        let contentItems = [];
        let currentIndex = 0;
        let isPlaying = false;
        let wpm = 300;
        let chunkSize = 1;
        let fontSize = 48;
        let fontFamily = 'Inter';
        let highlightMode = 'none';
        let isDyslexic        = false;
        let dyslexiaTint      = 'none';   // background tint colour key
        let letterSpacing     = 2;        // px, added inter-letter spacing
        let wordSpacing       = 4;        // px, added inter-word spacing
        let ttsWordHighlight  = true;     // highlight current word during TTS

        // Tint colour map (evidence-based tints from visual stress research)
        const TINT_COLORS = {
            none:     null,
            cream:    '#FEFAE0',
            yellow:   '#FFFACD',
            blue:     '#E8F4FD',
            green:    '#F0FBF0',
            peach:    '#FEF0E7',
            lavender: '#F3EFFE',
        };
        let theme = 'light';
        let animationFrame = null;
        let lastUpdate = 0;
        let sessionStartTime = null;
        let readingStreak = 0;
        let lastReadDate = null;
        let breakInterval = 25; // minutes
        let isChunkMode = false;          // section-by-section mode
        let chunkNextSectionStart = -1;   // word index where next section begins (after pause)
        const thumbnailCache = {};        // paperId → [dataURL, ...] — never persisted to localStorage
        let breakTimer = null;
        let readingStartTime = null;

        // Document sections for map
        let documentSections = [];
        let isDraggingViewport = false;
        let dragStartY = 0;
        let dragStartTop = 0;

        // Reading goals
        let weeklyGoal = { target: 10, current: 0 }; // papers per week
        let dailyGoal = { target: 60, current: 0 }; // minutes per day

        // Section summaries
        let currentSectionIndex = -1;
        let summaryGenerating = false;

        // DOM Elements
        const addPaperBtn = document.getElementById('addPaperBtn');
        const libraryList = document.getElementById('libraryList');
        const libraryCount = document.getElementById('libraryCount');
        const librarySearch = document.getElementById('librarySearch');
        const readerHeader = document.getElementById('readerHeader');
        const currentPaperTitle = document.getElementById('currentPaperTitle');
        const currentPaperMeta = document.getElementById('currentPaperMeta');
        const wpmSlider = document.getElementById('wpmSlider');
        const wpmValue = document.getElementById('wpmValue');
        const chunkSlider = document.getElementById('chunkSlider');
        const chunkValue = document.getElementById('chunkValue');
        const playBtn = document.getElementById('playBtn');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const bookmarkBtn = document.getElementById('bookmarkBtn');
        const highlightBtn = document.getElementById('highlightBtn');
        const restartBtn = document.getElementById('restartBtn');
        const progressText = document.getElementById('progressText');
        const headerProgressDisplay = document.getElementById('headerProgressDisplay');
        const headerPapersDisplay = document.getElementById('headerPapersDisplay');
        const timeRemaining = document.getElementById('timeRemaining');
        const progressFill = document.getElementById('progressFill');
        const focusToggle = document.getElementById('focusToggle');
        const goalsBtn = document.getElementById('goalsBtn');
        const exportAllBtn = document.getElementById('exportAllBtn');
        const shortcutsBtn = document.getElementById('shortcutsBtn');
        const streakDisplay = document.getElementById('streakDisplay');
        const streakCount = document.getElementById('streakCount');

        // Notes
        const notesKeyFindings = document.getElementById('notesKeyFindings');
        const notesSummary = document.getElementById('notesSummary');
        const notesRelevance = document.getElementById('notesRelevance');
        const notesQuestions = document.getElementById('notesQuestions');
        const saveNotesBtn = document.getElementById('saveNotesBtn');

        // Highlights
        const highlightsList = document.getElementById('highlightsList');
        const highlightCount = document.getElementById('highlightCount');

        // Map elements
        const mapContainer = document.getElementById('mapContainer');
        const mapSections = document.getElementById('mapSections');
        const mapViewport = document.getElementById('mapViewport');
        const mapProgress = document.getElementById('mapProgress');
        const mapPosition = document.getElementById('mapPosition');
        const mapSectionDisplay = document.getElementById('mapSectionDisplay');

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Auth first — redirects to /login if not authenticated
            const authed = await initAuth();
            if (!authed) return;

            // Wire logout button
            document.getElementById('logoutBtn')?.addEventListener('click', () => {
                if (confirm('Sign out of SwiftsReader?')) logout();
            });

            // Handle post-checkout redirect
            const params = new URLSearchParams(location.search);
            if (params.get('checkout') === 'success') {
                showNotification('🎉 Subscription activated! Enjoy unlimited summaries.', 'success');
                history.replaceState({}, '', '/app');
                // Refresh user data — Stripe webhook may take a moment, retry a few times
                let attempts = 0;
                const pollUpgrade = () => {
                    fetch('/api/auth/me', { headers: { 'Authorization': `Bearer ${getAuthToken()}` } })
                        .then(r => r.json())
                        .then(u => {
                            currentUser = u;
                            updateUserUI();
                            updateSummariesUI();
                            // Retry up to 5 times if still on free (webhook may be in-flight)
                            if (u.tier === 'free' && attempts++ < 5) setTimeout(pollUpgrade, 2000);
                        }).catch(() => {});
                };
                pollUpgrade();
            } else if (params.get('checkout') === 'cancelled') {
                history.replaceState({}, '', '/app');
            }

            loadSettings();
            loadLibrary();
            loadStreak();
            loadGoals();
            setupEventListeners();
            updateLibraryUI();
            updateHeaderStats();
        });

        // Load settings
        function loadSettings() {
            try {
                const settings = JSON.parse(localStorage.getItem('swiftsSettings') || '{}');
                
                if (settings.wpm) {
                    wpm = settings.wpm;
                    wpmSlider.value = wpm;
                    wpmValue.textContent = wpm;
                }
                
                if (settings.chunkSize) {
                    chunkSize = settings.chunkSize;
                    chunkSlider.value = chunkSize;
                    chunkValue.textContent = chunkSize + (chunkSize === 1 ? ' word' : ' words');
                }
                
                if (settings.fontSize) {
                    fontSize = settings.fontSize;
                    document.querySelectorAll('[data-size]').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.size) === fontSize);
                    });
                }
                
                if (settings.fontFamily) {
                    fontFamily = settings.fontFamily;
                    document.querySelectorAll('[data-font]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.font === fontFamily);
                    });
                }
                
                if (settings.highlightMode) {
                    highlightMode = settings.highlightMode;
                    document.querySelectorAll('[data-highlight]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.highlight === highlightMode);
                    });
                }
                
                if (settings.isDyslexic !== undefined) {
                    isDyslexic = settings.isDyslexic;
                    document.querySelectorAll('[data-dyslexia]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.dyslexia === String(isDyslexic));
                    });
                }
                if (settings.dyslexiaTint) {
                    dyslexiaTint = settings.dyslexiaTint;
                    document.querySelectorAll('.tint-btn').forEach(btn => {
                        const active = btn.dataset.tint === dyslexiaTint;
                        btn.style.border = active ? '2px solid var(--primary)' : '2px solid transparent';
                    });
                }
                if (settings.letterSpacing !== undefined) {
                    letterSpacing = settings.letterSpacing;
                    const ls = document.getElementById('letterSpacingSlider');
                    const lv = document.getElementById('letterSpacingVal');
                    if (ls) ls.value = letterSpacing;
                    if (lv) lv.textContent = '+' + letterSpacing + 'px';
                }
                if (settings.wordSpacing !== undefined) {
                    wordSpacing = settings.wordSpacing;
                    const ws = document.getElementById('wordSpacingSlider');
                    const wv = document.getElementById('wordSpacingVal');
                    if (ws) ws.value = wordSpacing;
                    if (wv) wv.textContent = '+' + wordSpacing + 'px';
                }
                if (settings.ttsWordHighlight !== undefined) {
                    ttsWordHighlight = settings.ttsWordHighlight;
                    document.querySelectorAll('[data-ttshighlight]').forEach(btn => {
                        btn.classList.toggle('active', (btn.dataset.ttshighlight === 'on') === ttsWordHighlight);
                    });
                }
                // Re-apply dyslexia mode after loading settings
                if (isDyslexic) applyDyslexiaMode();
                
                if (settings.theme) {
                    theme = settings.theme;
                    document.querySelectorAll('[data-theme]').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.theme === theme);
                    });
                    applyTheme(theme);
                }

                if (settings.breakInterval !== undefined) {
                    breakInterval = settings.breakInterval;
                    document.querySelectorAll('[data-break]').forEach(btn => {
                        btn.classList.toggle('active', parseInt(btn.dataset.break) === breakInterval);
                    });
                }

                console.log('[Settings] Loaded');
            } catch (error) {
                console.error('[Settings] Failed to load:', error);
            }
        }

        // Save settings
        function saveSettings() {
            try {
                const settings = {
                    wpm,
                    chunkSize,
                    fontSize,
                    fontFamily,
                    highlightMode,
                    isDyslexic,
                    theme,
                    breakInterval,
                    dyslexiaTint,
                    letterSpacing,
                    wordSpacing,
                    ttsWordHighlight,
                };
                localStorage.setItem('swiftsSettings', JSON.stringify(settings));
            } catch (error) {
                console.error('[Settings] Failed to save:', error);
            }
        }

        // Load library
        function loadLibrary() {
            try {
                library = JSON.parse(localStorage.getItem('swiftsLibrary') || '[]');
                console.log('[Library] Loaded', library.length, 'papers');
            } catch (error) {
                console.error('[Library] Failed to load:', error);
                library = [];
            }
        }

        // Save library — strip base64 images before persisting to avoid
        // hitting localStorage's ~5MB quota (images are kept in memory only)
        function saveLibrary() {
            try {
                const toSave = library.map(paper => {
                    // Strip heavy data that must not go to localStorage:
                    // figure base64 images AND page thumbnails (kept in thumbnailCache)
                    const { pageThumbnails, numPages, ...rest } = paper;
                    if (!rest.media || rest.media.length === 0) return rest;
                    return {
                        ...rest,
                        media: rest.media.map(m => {
                            if (m.type === 'figure' && m.image) {
                                const { image, ...mRest } = m;
                                return { ...mRest, imageStripped: true };
                            }
                            return m;
                        })
                    };
                });
                localStorage.setItem('swiftsLibrary', JSON.stringify(toSave));
                console.log('[Library] Saved (' + toSave.length + ' papers, images + thumbnails stripped for storage)');
            } catch (error) {
                console.error('[Library] Failed to save:', error);
                try {
                    const minimal = library.map(p => ({ ...p, text: '', media: [], pageThumbnails: undefined }));
                    localStorage.setItem('swiftsLibrary', JSON.stringify(minimal));
                    console.warn('[Library] Saved in minimal mode (text stripped)');
                } catch (e2) {
                    console.error('[Library] Could not save even minimal library:', e2);
                }
            }
        }

        // Load streak
        function loadStreak() {
            try {
                const streakData = JSON.parse(localStorage.getItem('swiftsStreak') || '{}');
                readingStreak = streakData.streak || 0;
                lastReadDate = streakData.lastDate || null;
                
                // Check if streak should continue or reset
                updateStreak();
            } catch (error) {
                console.error('[Streak] Failed to load:', error);
            }
        }

        // Update streak
        function updateStreak() {
            const today = new Date().toDateString();
            
            if (lastReadDate !== today) {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const yesterdayStr = yesterday.toDateString();
                
                if (lastReadDate === yesterdayStr) {
                    // Continue streak
                    readingStreak++;
                } else if (lastReadDate === null) {
                    // First time
                    readingStreak = 1;
                } else {
                    // Streak broken
                    readingStreak = 1;
                }
                
                lastReadDate = today;
                
                // Save streak
                localStorage.setItem('swiftsStreak', JSON.stringify({
                    streak: readingStreak,
                    lastDate: lastReadDate
                }));
            }
            
            // Display streak
            if (readingStreak > 0) {
                streakCount.textContent = readingStreak;
                streakDisplay.style.display = 'flex';
            }
        }

        // Load goals
        function loadGoals() {
            try {
                const goalsData = JSON.parse(localStorage.getItem('swiftsGoals') || '{}');
                weeklyGoal = goalsData.weekly || { target: 10, current: 0 };
                dailyGoal = goalsData.daily || { target: 60, current: 0 };
            } catch (error) {
                console.error('[Goals] Failed to load:', error);
            }
        }

        // Save goals
        function saveGoals() {
            try {
                localStorage.setItem('swiftsGoals', JSON.stringify({
                    weekly: weeklyGoal,
                    daily: dailyGoal
                }));
            } catch (error) {
                console.error('[Goals] Failed to save:', error);
            }
        }

        // Event Listeners
        function setupEventListeners() {
            // Add paper button
            addPaperBtn.addEventListener('click', () => {
                if (!canAddPaper()) return; // checks free tier paper limit
                showAddPaperModal();
            });

            // Library search
            librarySearch.addEventListener('input', (e) => {
                updateLibraryUI(e.target.value);
            });

            // WPM Slider
            wpmSlider.addEventListener('input', (e) => {
                wpm = parseInt(e.target.value);
                wpmValue.textContent = wpm;
                document.getElementById('headerWpmDisplay').textContent = wpm;
                updateStats();
                saveSettings();
                showPaperETA(); // refresh ETA estimate
            });

            // Chunk Size Slider
            chunkSlider.addEventListener('input', (e) => {
                chunkSize = parseInt(e.target.value);
                chunkValue.textContent = chunkSize + (chunkSize === 1 ? ' word' : ' words');
                saveSettings();
            });

            // Play/Pause (speed reader)
            playBtn.addEventListener('click', togglePlay);

            // Navigation
            prevBtn.addEventListener('click', () => {
                pause();
                currentIndex = Math.max(0, currentIndex - chunkSize);
                updateDisplay();
                updateStats();
                updateMapViewport();
                saveCurrentPaperProgress();
            });

            nextBtn.addEventListener('click', () => {
                pause();
                currentIndex = Math.min(contentItems.length - 1, currentIndex + chunkSize);
                updateDisplay();
                updateStats();
                updateMapViewport();
                saveCurrentPaperProgress();
            });

            // Bookmark
            bookmarkBtn.addEventListener('click', addBookmark);

            // Highlight
            highlightBtn.addEventListener('click', addHighlight);

            // Restart
            restartBtn.addEventListener('click', () => {
                if (!currentPaperId) return;
                pause();
                currentIndex = 0;
                updateDisplay();
                updateStats();
                updateSectionPips();
                updateMinimap();
                showPaperETA();
                saveCurrentPaperProgress();
                showNotification('↩ Restarted from the beginning');
            });

            // Save notes
            saveNotesBtn.addEventListener('click', saveNotes);

            // Font Size Buttons
            document.querySelectorAll('[data-size]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-size]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    fontSize = parseInt(btn.dataset.size);
                    updateDisplay();
                    saveSettings();
                });
            });

            // Font Family Buttons
            document.querySelectorAll('[data-font]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-font]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    fontFamily = btn.dataset.font;
                    updateDisplay();
                    saveSettings();
                });
            });

            // ── Dyslexia Mode toggle ────────────────────────────────────────
            document.querySelectorAll('[data-dyslexia]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-dyslexia]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    isDyslexic = btn.dataset.dyslexia === 'true';
                    // Evidence: slower reading improves comprehension for dyslexic readers
                    if (isDyslexic && audioSpeed === 1.0) {
                        audioSpeed = 0.75;
                        currentSpeedIndex = audioSpeeds.indexOf(0.75);
                        const speedEl = document.getElementById('audioSpeed');
                        if (speedEl) speedEl.textContent = '0.75x';
                    } else if (!isDyslexic && audioSpeed === 0.75) {
                        audioSpeed = 1.0;
                        currentSpeedIndex = audioSpeeds.indexOf(1.0);
                        const speedEl = document.getElementById('audioSpeed');
                        if (speedEl) speedEl.textContent = '1.0x';
                    }
                    applyDyslexiaMode();
                    updateDisplay();
                    saveSettings();
                });
            });

            // Tint buttons
            document.querySelectorAll('.tint-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tint-btn').forEach(b => {
                        b.style.border = '2px solid transparent';
                    });
                    btn.style.border = '2px solid var(--primary)';
                    dyslexiaTint = btn.dataset.tint;
                    applyDyslexiaMode();
                    saveSettings();
                });
            });

            // Letter spacing slider
            const letterSlider = document.getElementById('letterSpacingSlider');
            const letterVal    = document.getElementById('letterSpacingVal');
            if (letterSlider) letterSlider.addEventListener('input', () => {
                letterSpacing = parseInt(letterSlider.value);
                if (letterVal) letterVal.textContent = '+' + letterSpacing + 'px';
                applyDyslexiaMode();
                saveSettings();
            });

            // Word spacing slider
            const wordSlider = document.getElementById('wordSpacingSlider');
            const wordVal    = document.getElementById('wordSpacingVal');
            if (wordSlider) wordSlider.addEventListener('input', () => {
                wordSpacing = parseInt(wordSlider.value);
                if (wordVal) wordVal.textContent = '+' + wordSpacing + 'px';
                applyDyslexiaMode();
                saveSettings();
            });

            // TTS word highlight toggle
            document.querySelectorAll('[data-ttshighlight]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-ttshighlight]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    ttsWordHighlight = btn.dataset.ttshighlight === 'on';
                    saveSettings();
                });
            });

            // Highlight Mode Buttons
            document.querySelectorAll('[data-highlight]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-highlight]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    highlightMode = btn.dataset.highlight;
                    updateDisplay();
                    saveSettings();
                });
            });

            // Theme Buttons
            document.querySelectorAll('[data-theme]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-theme]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    theme = btn.dataset.theme;
                    applyTheme(theme);
                    saveSettings();
                });
            });

            // Template Buttons
            document.querySelectorAll('[data-template]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-template]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    applyTemplate(btn.dataset.template);
                });
            });

            // Break Timer Buttons
            document.querySelectorAll('[data-break]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('[data-break]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    breakInterval = parseInt(btn.dataset.break);
                    saveSettings();
                    resetBreakTimer();
                });
            });

            // Section-by-Section Chunk Mode
            document.querySelectorAll('[data-chunkmode]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-chunkmode]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    isChunkMode = btn.dataset.chunkmode === 'true';
                    showNotification(isChunkMode ? '📚 Section Mode: On — pauses at each section' : '📚 Section Mode: Off');
                });
            });

            // Focus Mode Toggle
            focusToggle.addEventListener('click', () => {
                document.body.classList.toggle('focus-mode');
                const isFocusMode = document.body.classList.contains('focus-mode');
                focusToggle.querySelector('span').textContent = isFocusMode ? '👁️' : '🎯';
                showNotification(isFocusMode ? '🎯 Focus Mode Enabled' : '👁️ Focus Mode Disabled');
            });

            // Goals
            goalsBtn.addEventListener('click', showGoalsModal);

            // Export
            exportAllBtn.addEventListener('click', showExportModal);

            // Shortcuts
            shortcutsBtn.addEventListener('click', showShortcutsModal);

            // Tabs
            document.querySelectorAll('.reader-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    
                    // Update active tab
                    document.querySelectorAll('.reader-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    
                    // Update active content
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                    document.querySelector(`[data-tab-content="${tabName}"]`).classList.add('active');
                });
            });

            // Keyboard Shortcuts
            document.addEventListener('keydown', handleKeyboard);

            // Save progress periodically
            setInterval(() => {
                if (isPlaying && currentPaperId) {
                    saveCurrentPaperProgress();
                }
            }, 10000); // Every 10 seconds

            // Window unload
            window.addEventListener('beforeunload', () => {
                if (currentPaperId) {
                    saveCurrentPaperProgress();
                    updatePaperStats();
                }
            });
        }

        // Handle keyboard shortcuts
        function handleKeyboard(e) {
            // Don't interfere with typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    togglePlay();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    prevBtn.click();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextBtn.click();
                    break;
                case 'f':
                case 'F':
                    e.preventDefault();
                    focusToggle.click();
                    break;
                case 'b':
                case 'B':
                    e.preventDefault();
                    addBookmark();
                    break;
                case 'h':
                case 'H':
                    e.preventDefault();
                    addHighlight();
                    break;
                case 'r':
                case 'R':
                    e.preventDefault();
                    pause();
                    currentIndex = 0;
                    updateDisplay();
                    updateStats();
                    updateMapViewport();
                    updateSectionPips();
                    updateMinimap();
                    showPaperETA();
                    saveCurrentPaperProgress();
                    showNotification('↩ Restarted from the beginning');
                    break;
            }
        }

        // Apply theme
        function applyTheme(themeName) {
            const root = document.documentElement;
            
            if (themeName === 'sepia') {
                root.style.setProperty('--bg-canvas', '#F4ECD8');
                root.style.setProperty('--bg-surface', '#FBF8F1');
                root.style.setProperty('--bg-secondary', '#EFE6D5');
                root.style.setProperty('--bg-tertiary', '#E5DBCA');
                root.style.setProperty('--text-primary', '#2C2416');
                root.style.setProperty('--text-secondary', '#5C5446');
                root.style.setProperty('--text-tertiary', '#8C8476');
            } else if (themeName === 'dark') {
                root.style.setProperty('--bg-canvas', '#1A1A1A');
                root.style.setProperty('--bg-surface', '#242424');
                root.style.setProperty('--bg-secondary', '#2E2E2E');
                root.style.setProperty('--bg-tertiary', '#383838');
                root.style.setProperty('--text-primary', '#E5E5E5');
                root.style.setProperty('--text-secondary', '#B5B5B5');
                root.style.setProperty('--text-tertiary', '#858585');
                root.style.setProperty('--border-light', '#383838');
                root.style.setProperty('--border-medium', '#484848');
            } else {
                root.style.setProperty('--bg-canvas', '#FAFAFA');
                root.style.setProperty('--bg-surface', '#FFFFFF');
                root.style.setProperty('--bg-secondary', '#F5F5F5');
                root.style.setProperty('--bg-tertiary', '#EEEEEE');
                root.style.setProperty('--text-primary', '#212121');
                root.style.setProperty('--text-secondary', '#616161');
                root.style.setProperty('--text-tertiary', '#9E9E9E');
                root.style.setProperty('--border-light', '#E0E0E0');
                root.style.setProperty('--border-medium', '#BDBDBD');
            }
        }

        // Apply reading template
        // ── Apply dyslexia mode settings to the whole app ──────────────────────
        function applyDyslexiaMode() {
            const root         = document.documentElement;
            const readerArea   = document.querySelector('.reader-area');
            const dyslexiaPanel = document.getElementById('dyslexiaControls');

            if (!isDyslexic) {
                // Reset everything dyslexia-specific
                document.body.classList.remove('dyslexia-mode');
                root.style.removeProperty('--dyslexia-letter-spacing');
                root.style.removeProperty('--dyslexia-word-spacing');
                if (readerArea) {
                    readerArea.style.removeProperty('background-color');
                    readerArea.style.removeProperty('max-width');
                }
                const wd = document.querySelector('.word-display');
                if (wd) {
                    wd.style.removeProperty('background-color');
                    wd.style.removeProperty('border-radius');
                    wd.style.removeProperty('padding');
                    wd.style.removeProperty('letter-spacing');
                    wd.style.removeProperty('word-spacing');
                }
                if (dyslexiaPanel) dyslexiaPanel.style.display = 'none';
                clearWordHighlight();
                return;
            }
            document.body.classList.add('dyslexia-mode');

            // Show the sub-controls panel
            if (dyslexiaPanel) dyslexiaPanel.style.display = '';

            // 1. Background tint (evidence: coloured overlays reduce visual stress)
            const tintColor = TINT_COLORS[dyslexiaTint];
            if (readerArea) {
                readerArea.style.backgroundColor = tintColor || '';
            }
            // Also tint the word display area
            const wordDisplay = document.querySelector('.word-display');
            if (wordDisplay) {
                wordDisplay.style.backgroundColor = tintColor || '';
                wordDisplay.style.borderRadius = tintColor ? '12px' : '';
                wordDisplay.style.padding = tintColor ? '16px' : '';
            }

            // 2. Letter spacing (evidence: Zorzi et al. 2012, Perea et al. 2012)
            root.style.setProperty('--dyslexia-letter-spacing', letterSpacing + 'px');

            // 3. Word spacing (evidence: inter-word spacing reduces crowding)
            root.style.setProperty('--dyslexia-word-spacing', wordSpacing + 'px');

            // 4. Narrow column — limits line length to ~60 chars (reduces crowding)
            if (readerArea) {
                readerArea.style.maxWidth = '640px';
            }

            // 5. Apply spacing to the reader display
            updateDyslexiaStyles();
        }

        // Apply letter/word spacing CSS to any currently rendered text
        function updateDyslexiaStyles() {
            if (!isDyslexic) return;
            const display = document.querySelector('.word-display');
            if (display) {
                display.style.letterSpacing = letterSpacing + 'px';
                display.style.wordSpacing   = wordSpacing + 'px';
            }
        }

        function applyTemplate(templateName) {
            const template = ReadingTemplates[templateName];
            if (!template) return;

            wpm = template.wpm;
            wpmSlider.value = wpm;
            wpmValue.textContent = wpm;
            document.getElementById('headerWpmDisplay').textContent = wpm;

            chunkSize = template.chunkSize;
            chunkSlider.value = chunkSize;
            chunkValue.textContent = chunkSize + (chunkSize === 1 ? ' word' : ' words');

            if (template.highlightMode) {
                highlightMode = template.highlightMode;
                document.querySelectorAll('[data-highlight]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.highlight === highlightMode);
                });
                updateDisplay();
            }

            if (template.fontSize) {
                fontSize = template.fontSize;
                document.querySelectorAll('[data-size]').forEach(btn => {
                    btn.classList.toggle('active', parseInt(btn.dataset.size) === fontSize);
                });
                updateDisplay();
            }

            saveSettings();
            updateStats();
            showNotification(`📋 Applied ${template.name} template`);
        }

        // Show add paper modal
        function showAddPaperModal() {
            const modal = createModal('Add Paper to Library', `
                <div class="form-group">
                    <label class="form-label">Title *</label>
                    <input type="text" id="paperTitle" placeholder="Paper title...">
                </div>
                <div class="form-group">
                    <label class="form-label">Authors</label>
                    <input type="text" id="paperAuthors" placeholder="Smith, J., Doe, A.">
                </div>
                <div class="form-group">
                    <label class="form-label">Year</label>
                    <input type="text" id="paperYear" placeholder="2024">
                </div>
                <div class="form-group">
                    <label class="form-label">Journal / Conference</label>
                    <input type="text" id="paperJournal" placeholder="Nature, ICML, etc.">
                </div>
                <div class="form-group">
                    <label class="form-label">DOI / URL</label>
                    <input type="text" id="paperDoi" placeholder="https://doi.org/...">
                </div>
                <div class="form-group">
                    <label class="form-label">Tags (comma-separated)</label>
                    <input type="text" id="paperTags" placeholder="machine-learning, nlp, high-priority">
                </div>
                <div class="form-group">
                    <label class="form-label">Upload File</label>
                    <input type="file" id="paperFile" accept=".txt,.pdf,.docx" style="padding: var(--space-sm); border: 1px solid var(--border-medium); border-radius: var(--radius-md);">
                </div>
                <div class="form-group">
                    <label class="form-label">Or Paste Text</label>
                    <textarea id="paperText" placeholder="Paste paper content here..." rows="6"></textarea>
                </div>
            `, () => {
                // On save
                const title = document.getElementById('paperTitle').value.trim();
                if (!title) {
                    showNotification('⚠️ Title is required', 'warning');
                    return false;
                }

                const paper = {
                    id: Date.now(),
                    title: title,
                    authors: document.getElementById('paperAuthors').value.trim(),
                    year: document.getElementById('paperYear').value.trim(),
                    journal: document.getElementById('paperJournal').value.trim(),
                    doi: document.getElementById('paperDoi').value.trim(),
                    tags: document.getElementById('paperTags').value.split(',').map(t => t.trim()).filter(t => t),
                    text: document.getElementById('paperText').value.trim(),
                    media: [],
                    file: null,
                    addedDate: new Date().toISOString(),
                    progress: 0,
                    currentIndex: 0,
                    bookmarks: [],
                    highlights: [],
                    summaries: [],
                    notes: {
                        keyFindings: '',
                        summary: '',
                        relevance: '',
                        questions: ''
                    },
                    readingTime: 0,
                    completed: false
                };

                const file = document.getElementById('paperFile').files[0];
                if (file) {
                    handlePaperFileUpload(file, paper);
                    return false; // Keep modal open while loading
                } else if (paper.text) {
                    library.unshift(paper);
                    saveLibrary();
                    updateLibraryUI();
                    updateHeaderStats();
                    showNotification(`📄 Added: ${title}`);
                    return true; // Close modal
                } else {
                    showNotification('⚠️ Please upload a file or paste text', 'warning');
                    return false;
                }
            });
        }

        // Handle paper file upload
        async function handlePaperFileUpload(file, paper) {
            try {
                showNotification('📂 Loading file...');

                let result = { text: '', media: [] };
                if (file.name.endsWith('.txt')) {
                    result.text = await file.text();
                } else if (file.name.endsWith('.pdf')) {
                    showNotification('📄 Extracting PDF content and images...');
                    result = await loadPDFText(file);
                } else if (file.name.endsWith('.docx')) {
                    showNotification('📝 Extracting DOCX content and images...');
                    result = await loadDOCXText(file);
                }

                paper.text = result.text;
                paper.media = result.media || [];
                paper.numPages = result.numPages || 0;
                // Store thumbnails in memory-only cache (not persisted to localStorage)
                if (result.pageThumbnails?.length) {
                    thumbnailCache[paper.id] = result.pageThumbnails;
                    console.log(`[Minimap] Cached ${result.pageThumbnails.length} thumbnails for paper ${paper.id}`);
                } else {
                    console.log('[Minimap] No thumbnails generated (non-PDF or failed)');
                }
                
                // Log what we extracted
                console.log('[Upload] Paper:', paper.title);
                console.log('[Upload] Text length:', result.text.length);
                console.log('[Upload] Media items:', paper.media.length);
                if (paper.media.length > 0) {
                    console.log('[Upload] Figures:', paper.media.filter(m => m.type === 'figure').length);
                    console.log('[Upload] Tables:', paper.media.filter(m => m.type === 'table').length);
                    console.log('[Upload] Media details:', paper.media);
                }
                
                library.unshift(paper);
                saveLibrary();
                updateLibraryUI();
                updateHeaderStats();
                
                // Close modal
                document.querySelector('.modal-overlay').remove();
                
                const figCount = paper.media.filter(m => m.type === 'figure').length;
                const tableCount = paper.media.filter(m => m.type === 'table').length;
                let mediaMsg = '';
                if (figCount > 0 || tableCount > 0) {
                    const parts = [];
                    if (figCount > 0) parts.push(`${figCount} figure${figCount !== 1 ? 's' : ''}`);
                    if (tableCount > 0) parts.push(`${tableCount} table${tableCount !== 1 ? 's' : ''}`);
                    mediaMsg = ` with ${parts.join(' and ')}`;
                }
                showNotification(`✅ Added: ${paper.title}${mediaMsg}`);
            } catch (error) {
                console.error('[File] Error:', error);
                showNotification('❌ Failed to load file', 'error');
            }
        }

        // Load PDF text with figures, tables, and equations
        async function loadPDFText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
            let fullText = '';
            let figureCount = 0;
            let tableCount = 0;
            let equationCount = 0;
            const mediaItems = [];

            // ── Pass 1: render each page to canvas (for image cropping) ─────────────
            console.log('[PDF] Rendering pages for image extraction...');
            const pageCanvases = [];
            const pageThumbnails = []; // small JPEG dataURLs for the minimap
            const THUMB_W = 180; // thumbnail width in px
            for (let i = 1; i <= pdf.numPages; i++) {
                try {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.5 });
                    const canvas = document.createElement('canvas');
                    canvas.width  = viewport.width;
                    canvas.height = viewport.height;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport }).promise;
                    pageCanvases.push({ pageNumber: i, canvas, viewport });

                    // Generate small thumbnail by scaling down the already-rendered canvas
                    try {
                        const tc = document.createElement('canvas');
                        const scale = THUMB_W / canvas.width;
                        tc.width  = THUMB_W;
                        tc.height = Math.round(canvas.height * scale);
                        tc.getContext('2d').drawImage(canvas, 0, 0, tc.width, tc.height);
                        pageThumbnails.push(tc.toDataURL('image/jpeg', 0.75));
                    } catch(te) {
                        console.warn('[PDF] Thumbnail failed for page', i, te);
                        pageThumbnails.push(null);
                    }
                } catch (err) {
                    console.warn('[PDF] Could not render page', i, err);
                    pageCanvases.push(null);
                    pageThumbnails.push(null);
                }
            }

            // ── Pass 2: detect ACTUAL embedded images via operator list ──────────────
            // This is the reliable method — finds images regardless of whether they
            // have a "Figure N" caption. getOperatorList() returns paintImageXObject
            // operations that correspond to real embedded images in the PDF.
            console.log('[PDF] Detecting embedded images via operator list...');
            const embeddedImagesByPage = {};

            for (let i = 1; i <= pdf.numPages; i++) {
                try {
                    const page = await pdf.getPage(i);
                    const opList = await page.getOperatorList();
                    const ops = opList.fnArray;
                    const args = opList.argsArray;

                    // OPS.paintImageXObject = 85, paintInlineImageXObject = 86,
                    // paintImageXObjectRepeat = 88
                    const IMAGE_OPS = new Set([85, 86, 88]);
                    const pageImages = [];

                    for (let j = 0; j < ops.length; j++) {
                        if (IMAGE_OPS.has(ops[j])) {
                            // args[j][0] is the image name/key
                            // We count it — position comes from surrounding transform ops
                            pageImages.push({ opIndex: j, name: args[j]?.[0] || `img_${j}` });
                        }
                    }

                    // Deduplicate by name (same image referenced multiple times = one image)
                    const seen = new Set();
                    const unique = pageImages.filter(img => {
                        if (seen.has(img.name)) return false;
                        seen.add(img.name);
                        return true;
                    });

                    if (unique.length > 0) {
                        embeddedImagesByPage[i] = unique;
                        console.log(`[PDF] Page ${i}: ${unique.length} embedded image(s)`);
                    }
                } catch (err) {
                    console.warn('[PDF] Operator list failed for page', i, err);
                }
            }

            // ── Pass 3: extract text + caption matching + merge with embedded images ─
            console.log('[PDF] Extracting text and matching captions...');

            // Caption patterns — broad to catch varied formatting
            const figPatterns = [
                /^(Figure|Fig\.?|FIG\.?)\s*(\d+[a-z]?)[:\.\-–—\s]\s*(.*)/i,
                /^(\d+)\s*\.\s*(Figure|Fig\.?)[:\.\-–—\s]\s*(.*)/i,
                /^(Figure|Fig\.?)\s*(\d+[a-z]?)\s*$/i,
            ];
            const tablePatterns = [
                /^Table\s*(\d+)[:\.\-–—\s]\s*(.*)/i,
                /^(\d+)\s*\.\s*Table[:\.\-–—\s]\s*(.*)/i,
            ];
            const equationPatterns = [
                /^(Equation|Eq\.?)\s*(\d+)[:\.\-–—\s]/i,
                /^\(\s*(\d+)\s*\)\s*$/,
            ];
            const mathSymbolDensity = s => {
                let count = 0;
                const mathUnicode = ['=','+','-','*','/','<','>','~','|','^','_',
                    '∑','∫','∂','∇','×','·','÷',
                    '√','∞','±','≈','≤','≥'];
                for (const ch of s) {
                    if (mathUnicode.includes(ch)) count++;
                    const code = ch.charCodeAt(0);
                    if (code >= 0x03B1 && code <= 0x03C9) count++; // α-ω
                    if (code >= 0x0391 && code <= 0x03A9) count++; // Α-Ω
                }
                return s.length > 0 ? count / s.length : 0;
            };

            // Track which pages we matched captions on so we don't double-add
            const captionMatchedPages = new Set();

            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const canvasData = pageCanvases[i - 1];

                const items = textContent.items.map(item => ({
                    str:  item.str,
                    x:    item.transform[4],
                    y:    item.transform[5],
                    w:    item.width,
                    h:    item.height || 0,
                    font: item.fontName || ''
                }));

                const pageText = items.map(it => it.str).join(' ');
                fullText += `[PAGE_${i}] ` + pageText + '\n\n';

                // Group text into logical lines
                const lineGroups = {};
                items.forEach(item => {
                    const rowKey = Math.round(item.y / 4) * 4;
                    if (!lineGroups[rowKey]) lineGroups[rowKey] = [];
                    lineGroups[rowKey].push(item);
                });
                const lines = Object.values(lineGroups)
                    .sort((a, b) => b[0].y - a[0].y)
                    .map(group => group.map(it => it.str).join(' ').trim())
                    .filter(l => l.length > 2);

                let pageHasCaptionMatch = false;

                // --- Match figure captions ---
                for (const line of lines) {
                    for (const pat of figPatterns) {
                        const m = line.match(pat);
                        if (m) {
                            figureCount++;
                            pageHasCaptionMatch = true;
                            const caption = (m[3] || m[2] || line).trim();

                            // Crop the figure region from the rendered canvas
                            let figImage = null;
                            if (canvasData) {
                                // Find caption Y on canvas (PDF coords are bottom-up)
                                const captionItems = items.filter(it =>
                                    it.str && it.str.length > 3 &&
                                    line.includes(it.str.slice(0, Math.min(10, it.str.length)))
                                );
                                if (captionItems.length > 0) {
                                    const scale = canvasData.viewport.scale;
                                    const canvasH = canvasData.canvas.height;
                                    // PDF y=0 is bottom of page; canvas y=0 is top
                                    const captionPdfY   = Math.min(...captionItems.map(it => it.y));
                                    const captionCanvasY = canvasH - (captionPdfY * scale);

                                    // Figures can be ABOVE or BELOW the caption.
                                    // Strategy: crop the larger region (above vs below caption).
                                    const aboveHeight = Math.max(0, captionCanvasY - 20);
                                    const belowHeight = Math.max(0, canvasH - captionCanvasY - 40);

                                    let figTop, figHeight;
                                    if (aboveHeight >= belowHeight && aboveHeight > 60) {
                                        // Figure is above caption (most common in papers)
                                        figTop    = Math.max(0, captionCanvasY - aboveHeight);
                                        figHeight = aboveHeight;
                                    } else if (belowHeight > 60) {
                                        // Figure is below caption (some layouts)
                                        figTop    = captionCanvasY + 20;
                                        figHeight = belowHeight;
                                    }

                                    if (figHeight && figHeight > 60) {
                                        const crop = document.createElement('canvas');
                                        crop.width  = canvasData.canvas.width;
                                        crop.height = Math.min(figHeight, 500);
                                        const ctx = crop.getContext('2d');
                                        ctx.drawImage(canvasData.canvas,
                                            0, figTop, crop.width, crop.height,
                                            0, 0,      crop.width, crop.height);
                                        figImage = crop.toDataURL('image/jpeg', 0.75); // JPEG saves ~4x space vs PNG
                                    }
                                }
                                // Fallback: use full page but compress heavily
                                if (!figImage) {
                                    const crop = document.createElement('canvas');
                                    crop.width  = Math.floor(canvasData.canvas.width * 0.5);
                                    crop.height = Math.floor(canvasData.canvas.height * 0.5);
                                    const ctx = crop.getContext('2d');
                                    ctx.drawImage(canvasData.canvas, 0, 0, crop.width, crop.height);
                                    figImage = crop.toDataURL('image/jpeg', 0.6);
                                }
                            }

                            fullText += `
[FIGURE_${figureCount}]
`;
                            mediaItems.push({ type: 'figure', number: figureCount,
                                              caption, image: figImage, pageNumber: i });
                            break;
                        }
                    }
                }

                // --- Match table captions ---
                for (const line of lines) {
                    for (const pat of tablePatterns) {
                        const m = line.match(pat);
                        if (m) {
                            tableCount++;
                            pageHasCaptionMatch = true;
                            const caption = (m[2] || line).trim();
                            fullText += `
[TABLE_${tableCount}]
`;
                            mediaItems.push({ type: 'table', number: tableCount,
                                              caption, content: '', pageNumber: i });
                            break;
                        }
                    }
                }

                // --- Equation detection ---
                for (const line of lines) {
                    let isEq = equationPatterns.some(p => line.match(p));
                    if (!isEq && line.length < 120 && mathSymbolDensity(line) > 0.25) isEq = true;
                    if (isEq) {
                        equationCount++;
                        fullText += `
[EQUATION_${equationCount}]
`;
                        mediaItems.push({ type: 'equation', number: equationCount,
                                          caption: `Equation ${equationCount}`, latex: line, pageNumber: i });
                    }
                }

                if (pageHasCaptionMatch) captionMatchedPages.add(i);
            }

            // ── Pass 4: add embedded images from pages with NO caption match ─────────
            // These are pages where real images exist but have no standard caption text.
            // We crop the full page and label them as uncaptioned figures.
            for (const [pageNumStr, images] of Object.entries(embeddedImagesByPage)) {
                const pageNum = parseInt(pageNumStr);
                if (captionMatchedPages.has(pageNum)) continue; // already handled via caption

                const canvasData = pageCanvases[pageNum - 1];
                if (!canvasData) continue;

                // Only add if there's a meaningful number of images (skip tiny icons/bullets)
                // We do this by checking if the page canvas has substantial non-white area
                // (simple heuristic — crop top 60% of page as the "figure area")
                for (let imgIdx = 0; imgIdx < images.length; imgIdx++) {
                    figureCount++;
                    const cropHeight = Math.floor(canvasData.canvas.height * 0.65);
                    const crop = document.createElement('canvas');
                    crop.width  = canvasData.canvas.width;
                    crop.height = cropHeight;
                    const ctx = crop.getContext('2d');
                    ctx.drawImage(canvasData.canvas, 0, 0, crop.width, cropHeight,
                                                     0, 0, crop.width, cropHeight);
                    const figImage = crop.toDataURL('image/jpeg', 0.7);

                    fullText += `
[FIGURE_${figureCount}]
`;
                    mediaItems.push({
                        type: 'figure',
                        number: figureCount,
                        caption: `Figure ${figureCount} (page ${pageNum})`,
                        image: figImage,
                        pageNumber: pageNum
                    });
                    // Only add one item per page even if multiple images detected
                    // (avoids duplicate crops of the same page)
                    break;
                }
            }

            // ── Pass 5: structured table extraction ──────────────────────────────────
            try {
                const structuredTables = await extractTablesFromPDF(pdf);
                const existingTablePages = new Set(mediaItems.filter(m => m.type === 'table').map(m => m.pageNumber));
                for (const tbl of structuredTables) {
                    if (!existingTablePages.has(tbl.pageNumber)) {
                        mediaItems.push(tbl);
                    }
                }
            } catch (e) {
                console.warn('[PDF] Structured table extraction failed:', e);
            }

            console.log(`[PDF] Extracted: ${figureCount} figures, ${tableCount} tables, ${equationCount} equations`);
            return { text: fullText, media: mediaItems, pageThumbnails, numPages: pdf.numPages };
        }

        // Load DOCX text with figures and tables
        async function loadDOCXText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const mediaItems = [];
            let imageCount = 0;
            let tableCount = 0;
            
            // First, extract images
            try {
                await mammoth.convert(
                    {arrayBuffer: arrayBuffer},
                    {
                        convertImage: mammoth.images.imgElement(function(image) {
                            return image.read("base64").then(function(imageBuffer) {
                                imageCount++;
                                const imageData = "data:" + image.contentType + ";base64," + imageBuffer;
                                mediaItems.push({
                                    type: 'figure',
                                    number: imageCount,
                                    caption: `Figure ${imageCount}`,
                                    image: imageData
                                });
                                return { src: imageData };
                            });
                        })
                    }
                );
                console.log('[DOCX] Extracted', imageCount, 'images');
            } catch (err) {
                console.warn('[DOCX] Could not extract images:', err);
            }
            
            // Now extract text
            const result = await mammoth.extractRawText({arrayBuffer});
            let text = result.value;
            let processedText = '';
            let figureCount = 0;
            
            const lines = text.split('\n');
            
            for (let line of lines) {
                const trimmedLine = line.trim();
                
                // Detect figure captions with better patterns
                const figurePatterns = [
                    /^(Figure|Fig\.?|FIG\.?)\s+(\d+)[:\.\-–—]?\s*(.*)$/i,
                    /^(\d+)\.\s+(Figure|Fig\.?)[:\.\-–—]?\s*(.*)$/i
                ];
                
                let figureFound = false;
                for (let pattern of figurePatterns) {
                    const figMatch = trimmedLine.match(pattern);
                    if (figMatch) {
                        figureCount++;
                        const caption = figMatch[3] || trimmedLine;
                        
                        // Find matching extracted image
                        const existingImage = mediaItems.find(
                            m => m.type === 'figure' && m.number === figureCount
                        );
                        
                        if (existingImage) {
                            existingImage.caption = caption.trim();
                        } else {
                            // Caption without image
                            mediaItems.push({
                                type: 'figure',
                                number: figureCount,
                                caption: caption.trim(),
                                image: null
                            });
                        }
                        
                        processedText += `\n[FIGURE_${figureCount}]\n`;
                        figureFound = true;
                        break;
                    }
                }
                
                if (figureFound) continue;
                
                // Detect table captions
                const tablePatterns = [
                    /^Table\s+(\d+)[:\.\-–—]?\s*(.*)$/i,
                    /^(\d+)\.\s+Table[:\.\-–—]?\s*(.*)$/i
                ];
                
                let tableFound = false;
                for (let pattern of tablePatterns) {
                    const tableMatch = trimmedLine.match(pattern);
                    if (tableMatch) {
                        tableCount++;
                        const caption = tableMatch[2] || trimmedLine;
                        
                        mediaItems.push({
                            type: 'table',
                            number: tableCount,
                            caption: caption.trim(),
                            content: ''
                        });
                        
                        processedText += `\n[TABLE_${tableCount}]\n`;
                        tableFound = true;
                        break;
                    }
                }
                
                if (tableFound) continue;
                
                processedText += line + '\n';
            }
            
            // Add markers for any images without captions
            if (imageCount > figureCount) {
                for (let i = figureCount + 1; i <= imageCount; i++) {
                    processedText += `\n[FIGURE_${i}]\n`;
                }
            }
            
            if (mediaItems.length > 0) {
                console.log('[DOCX] Total:', mediaItems.length, 'items -',
                    mediaItems.filter(m => m.type === 'figure').length, 'figures,',
                    mediaItems.filter(m => m.type === 'table').length, 'tables');
            }
            
            return { text: processedText || text, media: mediaItems };
        }

        // Update library UI
        function updateLibraryUI(searchQuery = '') {
            const query = searchQuery.toLowerCase();
            const filtered = library.filter(paper => {
                if (!query) return true;
                return paper.title.toLowerCase().includes(query) ||
                       (paper.authors && paper.authors.toLowerCase().includes(query)) ||
                       paper.tags.some(tag => tag.toLowerCase().includes(query));
            });

            libraryCount.textContent = filtered.length;

            if (filtered.length === 0) {
                libraryList.innerHTML = '<p style="text-align: center; color: var(--text-tertiary); font-size: 12px; padding: var(--space-lg);">No papers found</p>';
                return;
            }

            libraryList.innerHTML = filtered.map(paper => `
                <div class="library-item ${paper.id === currentPaperId ? 'active' : ''}" data-id="${paper.id}">
                    <div class="library-item-header">
                        <div class="library-item-title">${paper.title}</div>
                        <button class="library-item-menu" data-id="${paper.id}">⋮</button>
                    </div>
                    ${paper.authors ? `<div class="library-item-meta">${paper.authors}${paper.year ? ` (${paper.year})` : ''}</div>` : ''}
                    ${paper.tags.length > 0 ? `
                        <div class="library-item-tags">
                            ${paper.tags.map(tag => `<span class="tag">${tag}</span>`).join('')}
                        </div>
                    ` : ''}
                    <div class="library-item-progress">
                        <div class="library-item-progress-fill" style="width: ${paper.progress}%"></div>
                    </div>
                </div>
            `).join('');

            // Add click handlers
            document.querySelectorAll('.library-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('library-item-menu')) return;
                    const id = parseInt(item.dataset.id);
                    loadPaper(id);
                });
            });

            document.querySelectorAll('.library-item-menu').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    showPaperMenu(id, e);
                });
            });
        }

        // Show paper menu
        function showPaperMenu(paperId, event) {
            const paper = library.find(p => p.id === paperId);
            if (!paper) return;

            const menu = document.createElement('div');
            menu.className = 'modal-overlay';
            menu.innerHTML = `
                <div class="modal" style="max-width: 400px;">
                    <div class="modal-header">
                        <h2 class="modal-title">${paper.title}</h2>
                        <button class="modal-close">×</button>
                    </div>
                    <div class="modal-content">
                        <div class="button-group" style="display: grid; gap: var(--space-sm);">
                            <button class="button button-secondary" id="editPaperBtn">
                                ✏️ Edit Metadata
                            </button>
                            <button class="button button-secondary" id="exportPaperBtn">
                                💾 Export Paper Data
                            </button>
                            <button class="button button-secondary" id="duplicatePaperBtn">
                                📋 Duplicate
                            </button>
                            <button class="button button-secondary" id="deletePaperBtn" style="color: var(--error);">
                                🗑️ Delete Paper
                            </button>
                        </div>
                    </div>
                </div>
            `;

            document.body.appendChild(menu);

            const closeMenu = () => menu.remove();
            menu.querySelector('.modal-close').addEventListener('click', closeMenu);
            menu.addEventListener('click', (e) => {
                if (e.target === menu) closeMenu();
            });

            document.getElementById('editPaperBtn').addEventListener('click', () => {
                closeMenu();
                editPaper(paperId);
            });

            document.getElementById('exportPaperBtn').addEventListener('click', () => {
                exportPaper(paperId);
                closeMenu();
            });

            document.getElementById('duplicatePaperBtn').addEventListener('click', () => {
                duplicatePaper(paperId);
                closeMenu();
            });

            document.getElementById('deletePaperBtn').addEventListener('click', () => {
                if (confirm(`Delete "${paper.title}"? This cannot be undone.`)) {
                    deletePaper(paperId);
                    closeMenu();
                }
            });
        }

        // Load paper
        function loadPaper(paperId) {
            const paper = library.find(p => p.id === paperId);
            if (!paper) return;

            // Hide minimap sidebar until initMinimap decides if it should show
            const minimapSidebar = document.getElementById('minimapSidebar');
            if (minimapSidebar) minimapSidebar.style.display = 'none';

            // Save current paper if any
            if (currentPaperId) {
                saveCurrentPaperProgress();
                updatePaperStats();
            }

            currentPaperId = paperId;
            
            // Log paper info
            console.log('[Load Paper]', paper.title);
            console.log('[Load Paper] Media items:', paper.media?.length || 0);
            if (paper.media && paper.media.length > 0) {
                console.log('[Load Paper] Figures:', paper.media.filter(m => m.type === 'figure').length);
                console.log('[Load Paper] Tables:', paper.media.filter(m => m.type === 'table').length);
                paper.media.forEach((m, i) => {
                    console.log(`  [${i}] ${m.type} ${m.number}: ${m.caption.substring(0, 50)}... ${m.image ? '(has image)' : '(no image)'}`);
                });
            }
            
            parseText(paper.text);
            
            // Restore position
            currentIndex = paper.currentIndex || 0;
            
            // Update header
            readerHeader.style.display = 'block';
            currentPaperTitle.textContent = paper.title;
            currentPaperMeta.textContent = [
                paper.authors,
                paper.year,
                paper.journal
            ].filter(x => x).join(' • ');

            // Load notes
            notesKeyFindings.value = paper.notes.keyFindings || '';
            notesSummary.value = paper.notes.summary || '';
            notesRelevance.value = paper.notes.relevance || '';
            notesQuestions.value = paper.notes.questions || '';

            // Load highlights
            updateHighlightsUI();

            // Load media grid
            updateMediaGrid();

            // Load summaries
            updateSummariesUI();

            updateDisplay();
            updateStats();
            buildDocumentMap();
            updateLibraryUI();
            updateSectionPips();
            showPaperETA();
            initMinimap();

            const mediaCount = paper.media?.length || 0;
            const mediaInfo = mediaCount > 0 ? ` (${mediaCount} figures/tables)` : '';
            showNotification(`📖 Opened: ${paper.title}${mediaInfo}`);

            // Update streak
            updateStreak();

            // Start break timer
            resetBreakTimer();
        }

        // Enhanced table extraction from PDF
        async function extractTablesFromPDF(pdf) {
            console.log('[Tables] Starting enhanced table extraction...');
            const tables = [];
            
            try {
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    const textContent = await page.getTextContent();
                    
                    console.log(`[Tables] Scanning page ${pageNum}...`);
                    
                    // Get items with positioning
                    const items = textContent.items.map(item => ({
                        text: item.str.trim(),
                        x: item.transform[4],
                        y: item.transform[5],
                        width: item.width,
                        height: item.height,
                        font: item.fontName
                    })).filter(item => item.text.length > 0);

                    // Detect table headers (bold text, consistent x positions)
                    const potentialHeaders = items.filter(item => 
                        item.font && (item.font.includes('Bold') || item.font.includes('Heavy'))
                    );

                    // Group items by y position (rows)
                    const rowGroups = {};
                    const threshold = 5; // pixels tolerance
                    
                    items.forEach(item => {
                        const roundedY = Math.round(item.y / threshold) * threshold;
                        if (!rowGroups[roundedY]) {
                            rowGroups[roundedY] = [];
                        }
                        rowGroups[roundedY].push(item);
                    });

                    // Sort rows by y position (top to bottom)
                    const sortedRows = Object.keys(rowGroups)
                        .map(y => parseFloat(y))
                        .sort((a, b) => b - a); // PDF coords are bottom-up

                    // Detect potential tables (3+ consecutive rows with similar structure)
                    let tableStart = -1;
                    let tableRows = [];
                    
                    for (let i = 0; i < sortedRows.length; i++) {
                        const row = rowGroups[sortedRows[i]];
                        row.sort((a, b) => a.x - b.x); // Left to right
                        
                        // Check if this looks like a table row (multiple columns)
                        if (row.length >= 2) {
                            if (tableStart === -1) {
                                tableStart = i;
                                tableRows = [row];
                            } else {
                                tableRows.push(row);
                            }
                        } else if (tableStart !== -1 && tableRows.length >= 3) {
                            // End of table detected
                            const table = processTableRows(tableRows, pageNum, tables.length + 1);
                            if (table) {
                                tables.push(table);
                                console.log(`[Tables] ✅ Found table ${tables.length} on page ${pageNum}`);
                            }
                            tableStart = -1;
                            tableRows = [];
                        } else {
                            tableStart = -1;
                            tableRows = [];
                        }
                    }
                    
                    // Check for table at end of page
                    if (tableStart !== -1 && tableRows.length >= 3) {
                        const table = processTableRows(tableRows, pageNum, tables.length + 1);
                        if (table) {
                            tables.push(table);
                            console.log(`[Tables] ✅ Found table ${tables.length} on page ${pageNum}`);
                        }
                    }
                }
                
                console.log(`[Tables] ✅ Extracted ${tables.length} tables total`);
                return tables;
                
            } catch (error) {
                console.error('[Tables] Error extracting tables:', error);
                showNotification('⚠️ Some tables may not have been detected', 'warning');
                return tables;
            }
        }

        // Process table rows into structured data
        function processTableRows(rows, pageNum, tableNum) {
            if (rows.length < 3) return null;
            
            // Determine column positions from first few rows
            const columnPositions = detectColumnPositions(rows.slice(0, Math.min(5, rows.length)));
            
            if (columnPositions.length < 2) return null;
            
            // Extract table data
            const tableData = rows.map(row => {
                const rowData = [];
                columnPositions.forEach((colX, colIndex) => {
                    // Find items near this column position
                    const colItems = row.filter(item => {
                        const nextColX = columnPositions[colIndex + 1] || Infinity;
                        return item.x >= colX - 10 && item.x < nextColX;
                    });
                    rowData.push(colItems.map(item => item.text).join(' '));
                });
                return rowData;
            });
            
            // Detect header row (usually first row or bold)
            const headerRow = tableData[0];
            const dataRows = tableData.slice(1);
            
            // Create caption
            const caption = `Table ${tableNum}: ${headerRow.join(' | ')}`;
            
            // Generate HTML
            const html = generateTableHTML(headerRow, dataRows);
            
            return {
                type: 'table',
                number: tableNum,
                caption: caption,
                pageNumber: pageNum,
                headers: headerRow,
                rows: dataRows,
                html: html
            };
        }

        // Detect column positions from rows
        function detectColumnPositions(rows) {
            const xPositions = {};
            
            rows.forEach(row => {
                row.forEach(item => {
                    const roundedX = Math.round(item.x / 5) * 5;
                    xPositions[roundedX] = (xPositions[roundedX] || 0) + 1;
                });
            });
            
            // Get positions that appear frequently
            const threshold = Math.ceil(rows.length * 0.5);
            const positions = Object.keys(xPositions)
                .filter(x => xPositions[x] >= threshold)
                .map(x => parseFloat(x))
                .sort((a, b) => a - b);
            
            return positions;
        }

        // Generate HTML for table
        function generateTableHTML(headers, rows) {
            let html = '<table border="1" style="border-collapse: collapse; width: 100%; margin: 1em 0;">';
            
            // Header
            html += '<thead><tr>';
            headers.forEach(header => {
                html += `<th style="padding: 8px; background: var(--bg-secondary); border: 1px solid var(--border-medium); font-weight: 600;">${header}</th>`;
            });
            html += '</tr></thead>';
            
            // Body
            html += '<tbody>';
            rows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td style="padding: 8px; border: 1px solid var(--border-light);">${cell}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody>';
            
            html += '</table>';
            return html;
        }

        console.log('📊 Enhanced table detection loaded');

        // ============================================
        // AUTH & SUBSCRIPTION SYSTEM
        // ============================================

        // Current user state (loaded on init)
        let currentUser = null;

        const PAPER_LIMITS    = { free: 3,        student: Infinity, pro: Infinity };
        const SUMMARY_LIMITS  = { free: 20,       student: Infinity, pro: Infinity };

        function getAuthToken() {
            return localStorage.getItem('sr_token') || '';
        }

        function logout() {
            localStorage.removeItem('sr_token');
            localStorage.removeItem('sr_user');
            window.location.href = '/login';
        }

        // Load and verify auth on startup
        async function initAuth() {
            const token = getAuthToken();
            if (!token) {
                window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
                return false;
            }
            try {
                const r = await fetch('/api/auth/me', {
                    headers: { 'Authorization': `Bearer ${token}` }
                });
                if (!r.ok) {
                    localStorage.removeItem('sr_token');
                    window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
                    return false;
                }
                currentUser = await r.json();
                updateUserUI();
                return true;
            } catch {
                // Network issue — allow offline use but summaries won't work
                const cached = localStorage.getItem('sr_user');
                if (cached) currentUser = JSON.parse(cached);
                return true;
            }
        }

        function updateUserUI() {
            if (!currentUser) return;
            const emailEl = document.getElementById('userEmailDisplay');
            const badgeEl = document.getElementById('userTierBadge');
            const upgradeBtn = document.getElementById('upgradeBtn');
            if (emailEl) emailEl.textContent = currentUser.email;
            if (badgeEl) {
                const labels = { free: 'FREE', student: 'STUDENT', pro: 'PRO', beta: 'BETA' };
                const colors = {
                    free:    'background:#F3E5F5;color:#7B1FA2',
                    student: 'background:#E8F5E9;color:#2E7D32',
                    pro:     'background:#E3F2FD;color:#1565C0',
                    beta:    'background:#FFF3E0;color:#E65100'
                };
                const tier = currentUser.tier || 'free';
                badgeEl.textContent = labels[tier] || tier.toUpperCase();
                badgeEl.setAttribute('style', `padding:3px 10px;border-radius:20px;font-weight:700;font-size:11px;${colors[tier] || 'background:#eee;color:#333'}`);
            }
            if (upgradeBtn) upgradeBtn.style.display = (currentUser.tier === 'free') ? '' : 'none';
        }

        // Global Escape key handler — closes any open modal overlay instantly
        document.addEventListener('keydown', e => {
            if (e.key === 'Escape') {
                const overlays = document.querySelectorAll('.modal-overlay');
                if (overlays.length) {
                    overlays[overlays.length - 1].remove(); // close topmost
                    e.stopPropagation();
                }
            }
        });

        // Open upgrade modal (Stripe checkout)
        // Prevents stacking — only one upgrade modal open at a time
        async function openUpgradeModal(reason) {
            // Remove any existing upgrade modal before opening a new one
            document.getElementById('upgradeModalOverlay')?.remove();

            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            overlay.id = 'upgradeModalOverlay';
            overlay.innerHTML = `
                <div class="modal" style="max-width:520px;" role="dialog" aria-modal="true" aria-label="Upgrade SwiftsReader">
                    <div class="modal-header">
                        <h2 class="modal-title">✨ Upgrade SwiftsReader</h2>
                        <button class="modal-close" id="upgModalClose" aria-label="Close">×</button>
                    </div>
                    <div class="modal-content">
                        ${reason ? `<div style="background:#FFF8E1;border:1px solid #FFE082;border-radius:10px;padding:12px 14px;margin-bottom:16px;font-size:13px;color:#F57F17;">${reason}</div>` : ''}
                        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
                            <div style="border:2px solid var(--primary);border-radius:12px;padding:20px;text-align:center;">
                                <div style="font-size:22px;font-weight:800;margin-bottom:4px;">$12<span style="font-size:14px;font-weight:500;">/mo</span></div>
                                <div style="font-weight:700;font-size:15px;margin-bottom:10px;">Pro</div>
                                <ul style="text-align:left;font-size:13px;color:var(--text-secondary);list-style:none;padding:0;margin:0 0 16px;">
                                    <li>✅ Unlimited papers</li>
                                    <li>✅ Unlimited AI summaries</li>
                                    <li>✅ All reading features</li>
                                    <li>✅ Priority support</li>
                                </ul>
                                <button id="checkoutPro" class="button button-primary" style="width:100%;">Subscribe to Pro</button>
                            </div>
                            <div style="border:1px solid var(--border-light);border-radius:12px;padding:20px;text-align:center;">
                                <div style="font-size:22px;font-weight:800;margin-bottom:4px;">$6<span style="font-size:14px;font-weight:500;">/mo</span></div>
                                <div style="font-weight:700;font-size:15px;margin-bottom:10px;">Student</div>
                                <ul style="text-align:left;font-size:13px;color:var(--text-secondary);list-style:none;padding:0;margin:0 0 16px;">
                                    <li>✅ Everything in Pro</li>
                                    <li>✅ 50% off</li>
                                    <li>✅ Requires .edu email</li>
                                </ul>
                                <button id="checkoutStudent" class="button button-secondary" style="width:100%;">Student Plan</button>
                            </div>
                        </div>
                        <p style="font-size:12px;color:var(--text-tertiary);margin-top:12px;text-align:center;">Billed monthly · Cancel anytime · Secure payment via Stripe</p>
                    </div>
                </div>`;
            document.body.appendChild(overlay);

            const close = () => overlay.remove();

            // Close on X button
            overlay.querySelector('#upgModalClose').onclick = close;

            // Close on single click anywhere on the backdrop
            overlay.addEventListener('click', e => {
                if (e.target === overlay) close();
            });

            async function startCheckout(plan) {
                const btn = overlay.querySelector(`#checkout${plan.charAt(0).toUpperCase() + plan.slice(1)}`);
                btn.textContent = 'Redirecting…'; btn.disabled = true;
                try {
                    const r = await fetch('/api/stripe/checkout', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${getAuthToken()}` },
                        body: JSON.stringify({ plan })
                    });
                    const data = await r.json();
                    if (!r.ok) throw new Error(data.error || 'Checkout failed');
                    window.location.href = data.url;
                } catch (err) {
                    showNotification('❌ ' + err.message, 'error');
                    btn.textContent = plan === 'pro' ? 'Subscribe to Pro' : 'Student Plan';
                    btn.disabled = false;
                }
            }

            overlay.querySelector('#checkoutPro').onclick     = () => startCheckout('pro');
            overlay.querySelector('#checkoutStudent').onclick = () => startCheckout('student');

            // Focus the close button for keyboard accessibility
            setTimeout(() => overlay.querySelector('#upgModalClose')?.focus(), 50);
        }
        window.openUpgradeModal = openUpgradeModal;

        // Check paper limit before adding a paper
        function canAddPaper() {
            // If auth hasn't loaded yet, allow optimistically — initAuth will gate the app anyway
            if (!currentUser) return true;
            const tier  = currentUser.tier || 'free';
            const limit = PAPER_LIMITS[tier] ?? 3;
            if (!isFinite(limit)) return true; // pro / student / beta = unlimited
            if (library.length >= limit) {
                openUpgradeModal(`📚 Free plan includes up to ${limit} papers. Upgrade to Pro for unlimited papers.`);
                return false;
            }
            return true;
        }

        // ============================================
        // AI SUMMARY — Secure server-side proxy
        // ============================================


        async function generateSectionSummary(sectionIndex) {
            console.log(`[AI] Generating summary for section ${sectionIndex}...`);

            if (!currentPaperId) { showNotification('❌ No document loaded', 'error'); return null; }
            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) { showNotification('❌ Document not found', 'error'); return null; }
            const section = documentSections[sectionIndex];
            if (!section) { showNotification('❌ Section not found', 'error'); return null; }

            const minWords = 100;
            if (!section.words || section.words.length < minWords) {
                showNotification(`⚠️ Section too short (${section.words?.length || 0}/${minWords} words minimum).`, 'warning');
                return null;
            }

            const content = section.words.slice(0, 6000).join(' ');

            try {
                const response = await fetch('/api/summarise', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${getAuthToken()}`
                    },
                    body: JSON.stringify({ sectionTitle: section.title, content })
                });

                const data = await response.json();

                if (!response.ok) {
                    // Limit reached → offer upgrade
                    if (data.code === 'LIMIT_REACHED') {
                        openUpgradeModal(`🤖 You've used all ${data.limit} free AI summaries this month. Upgrade for unlimited summaries.`);
                        return null;
                    }
                    if (response.status === 401) {
                        window.location.href = '/login';
                        return null;
                    }
                    showNotification(`❌ ${data.error || 'AI error'}`, 'error');
                    return null;
                }

                // Update cached user usage count
                if (data.usage && currentUser) {
                    currentUser.summariesUsed = data.usage.used;
                    currentUser.summariesLimit = data.usage.limit;
                }

                showNotification('✅ Summary generated!', 'success');
                return {
                    sectionIndex,
                    sectionTitle: section.title || 'Untitled',
                    overview:    data.overview   || 'No overview available',
                    keyPoints:   Array.isArray(data.keyPoints) ? data.keyPoints : [],
                    importance:  data.importance || '',
                    timestamp:   Date.now()
                };

            } catch (error) {
                console.error('[AI] Error:', error);
                showNotification('❌ AI summary failed: ' + error.message, 'error');
                return null;
            }
        }

        console.log('✅ AI Summary module loaded — secure server-side proxy active');

        // Display section summary
        async function showSectionSummary(sectionIndex) {
            if (summaryGenerating) return;
            summaryGenerating = true;
            currentSectionIndex = sectionIndex;

            const displayEl = document.querySelector('.reader-display');
            const section = documentSections[sectionIndex];

            // Check section has enough words
            if (!section || !section.words || section.words.length < 100) {
                summaryGenerating = false;
                displayEl.innerHTML = `
                    <div class="section-summary-display">
                        <div class="section-summary-header">
                            <div class="section-summary-icon">📚</div>
                            <div class="section-summary-title">
                                <h3>${section?.title || 'Section'}</h3>
                                <p>${section?.words?.length || 0} words — too short to summarise</p>
                            </div>
                        </div>
                        <div class="section-summary-actions">
                            <button class="button button-secondary" onclick="prevBtn.click()">← Previous</button>
                            <button class="button button-primary" onclick="nextBtn.click()">Continue Reading →</button>
                        </div>
                    </div>`;
                return;
            }

            // Show generating state
            displayEl.innerHTML = `
                <div class="section-summary-display">
                    <div class="section-summary-header">
                        <div class="section-summary-icon">📋</div>
                        <div class="section-summary-title">
                            <h3>${section.title}</h3>
                            <p>~${section.words.length} words</p>
                        </div>
                    </div>
                    <div class="summary-generating">
                        <div class="summary-spinner"></div>
                        <div>Generating AI summary...</div>
                    </div>
                </div>
            `;

            // Generate or retrieve summary
            const paper = library.find(p => p.id === currentPaperId);
            let summary = paper.summaries?.find(s => s.sectionIndex === sectionIndex);
            
            if (!summary) {
                summary = await generateSectionSummary(sectionIndex);
                
                // Save summary to paper
                if (summary && paper) {
                    if (!paper.summaries) {
                        paper.summaries = [];
                    }
                    paper.summaries.push(summary);
                    saveLibrary();
                }
            }

            summaryGenerating = false;

            if (!summary) {
                displayEl.innerHTML = `
                    <div class="section-summary-display">
                        <div class="section-summary-header">
                            <div class="section-summary-icon">📋</div>
                            <div class="section-summary-title">
                                <h3>${section.title}</h3>
                                <p>~${section.words.length} words</p>
                            </div>
                        </div>
                        <div class="summary-error">
                            Failed to generate summary. Click continue to proceed with reading.
                        </div>
                        <div class="section-summary-actions">
                            <button class="button button-primary" onclick="nextBtn.click()">Continue Reading →</button>
                        </div>
                    </div>
                `;
                return;
            }

            // Display summary
            try {
                let keyPointsHTML = '';
                if (summary && summary.keyPoints && Array.isArray(summary.keyPoints) && summary.keyPoints.length > 0) {
                    keyPointsHTML = `
                        <div class="summary-block">
                            <div class="summary-block-title">Key Points</div>
                            <div class="summary-block-content">
                                <ul>
                                    ${summary.keyPoints.map(p => `<li>${String(p).replace(/^- /, '')}</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                    `;
                }

                let importanceHTML = '';
                if (summary && summary.importance) {
                    importanceHTML = `
                        <div class="summary-block">
                            <div class="summary-block-title">Importance</div>
                            <div class="summary-block-content">
                                ${String(summary.importance)}
                            </div>
                        </div>
                    `;
                }

                displayEl.innerHTML = `
                    <div class="section-summary-display">
                        <div class="section-summary-header">
                            <div class="section-summary-icon">📋</div>
                            <div class="section-summary-title">
                                <h3>${section.title}</h3>
                                <p>~${section.words.length} words • Section ${sectionIndex + 1}/${documentSections.length}</p>
                            </div>
                        </div>
                        <div class="section-summary-content">
                            <div class="summary-block">
                                <div class="summary-block-title">Summary</div>
                                <div class="summary-block-content">${summary && summary.overview ? String(summary.overview) : 'No summary available'}</div>
                            </div>
                            ${keyPointsHTML}
                            ${importanceHTML}
                        </div>
                        <div class="section-summary-actions">
                            <button class="button button-secondary" onclick="prevBtn.click()">← Previous</button>
                            <button class="button button-primary" onclick="nextBtn.click()">Continue Reading →</button>
                        </div>
                    </div>
                `;
            } catch (displayError) {
                console.error('[Summary Display] Error rendering summary:', displayError);
                displayEl.innerHTML = `
                    <div class="section-summary-display">
                        <div class="section-summary-header">
                            <div class="section-summary-icon">⚠️</div>
                            <div class="section-summary-title">
                                <h3>${section.title}</h3>
                                <p>Display Error</p>
                            </div>
                        </div>
                        <div class="summary-error">
                            There was an error displaying the summary. Please try again or continue reading.
                        </div>
                        <div class="section-summary-actions">
                            <button class="button button-primary" onclick="nextBtn.click()">Continue Reading →</button>
                        </div>
                    </div>
                `;
            }
        }

        // Update summaries UI in tab
        function updateSummariesUI() {
            const summariesList  = document.getElementById('summariesList');
            const summariesCount = document.getElementById('summariesCount');

            if (!currentPaperId) {
                summariesList.innerHTML = '<p style="text-align:center;color:var(--text-tertiary);padding:var(--space-2xl);">No paper selected</p>';
                summariesCount.textContent = '(0)';
                return;
            }

            const paper      = library.find(p => p.id === currentPaperId);
            const summaries  = paper?.summaries || [];
            const sectionCount = documentSections.length;
            const wordCount    = documentSections.reduce((n, s) => n + (s.words?.length || 0), 0);

            summariesCount.textContent = `(${summaries.length})`;

            // ── Usage status bar ──────────────────────────────────────────────
            let statusHtml = '';
            if (currentUser) {
                const tier   = currentUser.tier || 'free';
                const used   = currentUser.summariesUsed  || 0;
                const limit  = currentUser.summariesLimit;  // null = unlimited
                const isUnlimited = tier !== 'free';

                if (isUnlimited) {
                    statusHtml = `<div style="font-size:12px;color:var(--success);font-weight:600;margin-bottom:var(--space-md);">
                        ✅ ${tier === 'student' ? 'Student' : 'Pro'} plan — unlimited AI summaries
                    </div>`;
                } else {
                    const left = Math.max(0, (limit || 20) - used);
                    const pct  = Math.min(100, (used / (limit || 20)) * 100);
                    const barColor = left === 0 ? 'var(--error)' : left <= 1 ? 'var(--warning)' : 'var(--primary)';
                    statusHtml = `
                    <div style="background:var(--bg-secondary);border-radius:var(--radius-md);padding:var(--space-sm) var(--space-md);margin-bottom:var(--space-md);">
                        <div style="display:flex;justify-content:space-between;align-items:center;font-size:12px;margin-bottom:6px;">
                            <span style="font-weight:600;">${used} / ${limit || 20} AI summaries used this month</span>
                            ${left === 0
                                ? `<button onclick="openUpgradeModal()" style="background:var(--primary);color:white;border:none;border-radius:6px;padding:3px 10px;font-size:11px;font-weight:700;cursor:pointer;">Upgrade for more ✨</button>`
                                : `<span style="color:var(--text-tertiary)">${left} remaining</span>`}
                        </div>
                        <div style="background:var(--border-light);border-radius:4px;height:4px;overflow:hidden;">
                            <div style="width:${pct}%;height:100%;background:${barColor};transition:width .3s;"></div>
                        </div>
                    </div>`;
                }
            }

            const debugHtml = sectionCount > 0
                ? `<div style="font-size:11px;color:var(--text-tertiary);margin-bottom:var(--space-md);">${sectionCount} section${sectionCount !== 1 ? 's' : ''} detected · ~${wordCount.toLocaleString()} words</div>`
                : '';

            if (summaries.length === 0) {
                summariesList.innerHTML = statusHtml + debugHtml +
                    `<p style="text-align:center;color:var(--text-tertiary);padding:var(--space-xl);">
                        No summaries yet.<br>Click <strong>✨ Generate All Summaries</strong> above.
                    </p>`;
            } else {
                summariesList.innerHTML = statusHtml + debugHtml + summaries
                    .slice().sort((a, b) => a.sectionIndex - b.sectionIndex)
                    .map(s => {
                        const kpHTML = s.keyPoints?.length
                            ? `<ul style="margin-top:var(--space-sm);padding-left:var(--space-lg);font-size:13px;">${s.keyPoints.slice(0, 4).map(p => `<li>${String(p).replace(/^- /, '')}</li>`).join('')}</ul>` : '';
                        return `
                            <div class="summary-item">
                                <div class="summary-item-header">
                                    <div class="summary-item-title">${s.sectionTitle}</div>
                                    <div class="summary-item-badge">Section ${s.sectionIndex + 1}</div>
                                </div>
                                <div class="summary-block-content" style="margin-bottom:var(--space-sm);">${s.overview || 'No overview'}</div>
                                ${kpHTML}
                                ${s.importance ? `<div style="font-size:12px;color:var(--text-secondary);margin-top:var(--space-sm);font-style:italic;">💡 ${s.importance}</div>` : ''}
                                <button class="toggle-summary" data-jump="${s.sectionIndex}" style="margin-top:var(--space-sm);">📍 Jump to Section</button>
                            </div>`;
                    }).join('');
            }

            // Jump buttons
            summariesList.querySelectorAll('[data-jump]').forEach(btn => {
                btn.addEventListener('click', () => jumpToSectionSummary(parseInt(btn.dataset.jump)));
            });
        }

        // Jump to section summary
        window.jumpToSectionSummary = function(sectionIndex) {
            // Switch to read tab
            document.querySelectorAll('.reader-tab').forEach(t => t.classList.remove('active'));
            document.querySelector('[data-tab="read"]').classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.querySelector('[data-tab-content="read"]').classList.add('active');
            
            // Show the section summary
            showSectionSummary(sectionIndex);
        };

        // Generate all summaries
        document.getElementById('generateAllSummariesBtn')?.addEventListener('click', async () => {
            if (!currentPaperId) { showNotification('⚠️ No paper loaded', 'warning'); return; }
            if (documentSections.length === 0) { showNotification('⚠️ No sections detected', 'warning'); return; }

            const paper = library.find(p => p.id === currentPaperId);
            const MIN_WORDS = 100;
            const eligible  = documentSections.filter((sec, i) =>
                sec.words && sec.words.length >= MIN_WORDS && !paper.summaries?.find(s => s.sectionIndex === i)
            );
            const alreadyDone = documentSections.filter((_, i) => paper.summaries?.find(s => s.sectionIndex === i)).length;

            if (eligible.length === 0) {
                showNotification(alreadyDone > 0 ? `✅ All sections already summarised` : `⚠️ No sections with ${MIN_WORDS}+ words`, 'info');
                return;
            }

            // Warn free users about quota
            const tier  = currentUser?.tier || 'free';
            const limit = currentUser?.summariesLimit;
            const used  = currentUser?.summariesUsed || 0;
            const remaining = limit != null ? Math.max(0, limit - used) : Infinity;

            if (tier === 'free' && remaining === 0) {
                openUpgradeModal(`🤖 You've used all your free AI summaries this month. Upgrade for unlimited summaries.`);
                return;
            }

            const toGenerate = tier === 'free' ? Math.min(eligible.length, remaining) : eligible.length;
            const msg = tier === 'free' && toGenerate < eligible.length
                ? `Generate ${toGenerate} of ${eligible.length} summaries (${remaining} free uses remaining)?`
                : `Generate AI summaries for ${eligible.length} section(s)${alreadyDone ? ` (${alreadyDone} already done)` : ''}?`;

            if (!confirm(msg)) return;

            const summariesList = document.getElementById('summariesList');
            summariesList.innerHTML = `<div style="text-align:center;padding:var(--space-2xl);">
                <div class="summary-spinner"></div>
                <p id="summaryProgress" style="margin-top:var(--space-md);color:var(--text-secondary);">Generating… 0 / ${toGenerate}</p>
            </div>`;

            let generated = 0;
            for (let i = 0; i < documentSections.length; i++) {
                if (generated >= toGenerate) break;
                const sec = documentSections[i];
                if (!sec.words || sec.words.length < MIN_WORDS) continue;
                if (paper.summaries?.find(s => s.sectionIndex === i)) continue;
                document.getElementById('summaryProgress').textContent = `Generating… ${generated} / ${toGenerate} — "${sec.title}"`;
                const summary = await generateSectionSummary(i);
                if (summary) {
                    if (!paper.summaries) paper.summaries = [];
                    paper.summaries.push(summary);
                    saveLibrary();
                    generated++;
                }
                await new Promise(r => setTimeout(r, 600));
            }
            updateSummariesUI();
            showNotification(`✅ Generated ${generated} / ${toGenerate} summaries`, 'success');
        });

        // Parse text into content items
        function parseText(text) {
            if (!text || text.trim().length === 0) {
                contentItems = [];
                currentIndex = 0;
                updateDisplay();
                updateStats();
                return;
            }

            contentItems = [];
            
            // Get current paper's media items
            const paper = library.find(p => p.id === currentPaperId);
            const mediaItems = paper?.media || [];

            // Track current page number as we parse
            let currentPageNum = 1;
            
            // Split into segments including PAGE markers, figure/table markers
            const segments = text.split(/(\[PAGE_\d+\]|\[FIGURE_\d+\]|\[TABLE_\d+\])/);
            
            segments.forEach((segment) => {
                // Handle page marker — update page tracker, don't push a content item
                const pageMatch = segment.match(/\[PAGE_(\d+)\]/);
                if (pageMatch) {
                    currentPageNum = parseInt(pageMatch[1]);
                    return;
                }

                // Check if this is a figure marker
                const figureMatch = segment.match(/\[FIGURE_(\d+)\]/);
                if (figureMatch) {
                    const figureNum = parseInt(figureMatch[1]);
                    const figure = mediaItems.find(m => m.type === 'figure' && m.number === figureNum);
                    
                    contentItems.push({
                        type: ContentType.FIGURE,
                        number: figureNum,
                        caption: figure?.caption || `Figure ${figureNum}`,
                        image: figure?.image || null,
                        page: currentPageNum
                    });
                    
                    // Add pause after figure
                    contentItems.push({
                        type: ContentType.PAUSE,
                        duration: 2000 // 2 second pause to view figure
                    });
                    return;
                }
                
                // Check if this is a table marker
                const tableMatch = segment.match(/\[TABLE_(\d+)\]/);
                if (tableMatch) {
                    const tableNum = parseInt(tableMatch[1]);
                    const table = mediaItems.find(m => m.type === 'table' && m.number === tableNum);
                    
                    contentItems.push({
                        type: ContentType.TABLE,
                        number: tableNum,
                        caption: table?.caption || `Table ${tableNum}`,
                        content: table?.content || '',
                        page: currentPageNum
                    });
                    
                    // Add pause after table
                    contentItems.push({
                        type: ContentType.PAUSE,
                        duration: 2000 // 2 second pause to view table
                    });
                    return;
                }
                
                // Regular text segment
                if (segment.trim().length === 0) return;
                
                const sentences = segment
                    .replace(/\n+/g, '. ')
                    .split(/(?<=[.!?])\s+/)
                    .filter(s => s.trim().length > 0);

                sentences.forEach((sentence, idx) => {
                    const words = sentence.trim().split(/\s+/).filter(w => w.length > 0);
                    
                    words.forEach(word => {
                        contentItems.push({
                            type: ContentType.TEXT,
                            content: word,
                            page: currentPageNum
                        });
                    });

                    if (idx < sentences.length - 1) {
                        contentItems.push({
                            type: ContentType.PAUSE,
                            duration: 300
                        });
                    }
                });
            });

            console.log('[Parse] Loaded', contentItems.length, 'items');
        }

        // Update display
        function updateDisplay() {
            const displayEl = document.querySelector('.reader-display');
            const placeholder = displayEl.querySelector('.reader-placeholder');
            
            if (contentItems.length === 0) {
                if (!placeholder) {
                    displayEl.innerHTML = `
                        <div class="reader-placeholder">
                            <div class="reader-placeholder-icon">📖</div>
                            <h3>Welcome to SwiftsReader</h3>
                            <p>Add a paper to your library or paste text to begin reading. Designed for academics with ADHD and dyslexia support.</p>
                        </div>
                    `;
                }
                return;
            }

            if (placeholder) {
                placeholder.remove();
            }

            const currentItem = contentItems[currentIndex];
            
            // Display figure
            if (currentItem && currentItem.type === ContentType.FIGURE) {
                let html = '<div class="figure-display">';
                
                if (currentItem.image) {
                    html += `<img src="${currentItem.image}" alt="${currentItem.caption}" onclick="zoomImage(this.src)">`;
                } else {
                    html += '<div style="padding: var(--space-2xl); background: var(--bg-secondary); border-radius: var(--radius-md); color: var(--text-tertiary); font-size: 48px;">📊</div>';
                }
                
                html += `<div class="figure-caption"><span class="figure-number">Figure ${currentItem.number}:</span> ${currentItem.caption}</div>`;
                html += '<div class="pause-indicator">⏸ Reading paused for figure</div>';
                html += '<div class="media-controls">';
                html += '<button class="media-button" onclick="prevBtn.click()">← Previous</button>';
                html += '<button class="media-button" onclick="nextBtn.click()">Continue →</button>';
                html += '</div>';
                html += '</div>';
                
                displayEl.innerHTML = html;
                return;
            }
            
            // Display table
            if (currentItem && currentItem.type === ContentType.TABLE) {
                let html = '<div class="table-display">';
                html += `<div class="table-caption"><span class="figure-number">Table ${currentItem.number}:</span> ${currentItem.caption}</div>`;
                
                if (currentItem.content) {
                    // Try to parse table content into HTML table
                    const rows = currentItem.content.trim().split('\n').filter(r => r.trim());
                    if (rows.length > 0) {
                        html += '<table>';
                        rows.forEach((row, idx) => {
                            const cells = row.split(/\t|  +/); // Split on tabs or multiple spaces
                            html += '<tr>';
                            cells.forEach(cell => {
                                const tag = idx === 0 ? 'th' : 'td';
                                html += `<${tag}>${cell.trim()}</${tag}>`;
                            });
                            html += '</tr>';
                        });
                        html += '</table>';
                    } else {
                        html += '<p style="text-align: center; color: var(--text-tertiary); padding: var(--space-xl);">Table content not available</p>';
                    }
                } else {
                    html += '<p style="text-align: center; color: var(--text-tertiary); padding: var(--space-xl);">Table content not available</p>';
                }
                
                html += '<div class="pause-indicator">⏸ Reading paused for table</div>';
                html += '<div class="media-controls">';
                html += '<button class="media-button" onclick="prevBtn.click()">← Previous</button>';
                html += '<button class="media-button" onclick="nextBtn.click()">Continue →</button>';
                html += '</div>';
                html += '</div>';
                
                displayEl.innerHTML = html;
                return;
            }

            // Display regular text
            const chunk = [];
            for (let i = 0; i < chunkSize && currentIndex + i < contentItems.length; i++) {
                const item = contentItems[currentIndex + i];
                if (item.type === ContentType.TEXT) {
                    chunk.push(item.content);
                }
            }

            let html = '<div class="word-display';
            if (highlightMode !== 'none') {
                html += ` highlight-${highlightMode}`;
            }
            html += '"';
            
            html += ` style="font-size: ${fontSize}px; font-family: `;
            if (isDyslexic) {
                html += 'OpenDyslexic, ';
            }
            html += `${fontFamily}, sans-serif;">`;
            
            chunk.forEach(word => {
                html += `<span class="word">${word}</span>`;
            });
            
            html += '</div>';
            
            displayEl.innerHTML = html;

            // Apply dyslexia spacing and font after render
            if (isDyslexic) {
                const wd = displayEl.querySelector('.word-display');
                if (wd) {
                    wd.style.letterSpacing = letterSpacing + 'px';
                    wd.style.wordSpacing   = wordSpacing + 'px';
                    // Apply tint to the display box too
                    const tintColor = TINT_COLORS[dyslexiaTint];
                    if (tintColor) {
                        wd.style.backgroundColor = tintColor;
                        wd.style.borderRadius    = '12px';
                        wd.style.padding         = '16px';
                    }
                }
            }
        }

        // Zoom image
        function zoomImage(src) {
            const overlay = document.createElement('div');
            overlay.className = 'image-zoom-overlay';
            overlay.innerHTML = `
                <button class="image-zoom-close" onclick="this.parentElement.remove()">×</button>
                <img src="${src}" class="image-zoom-content">
            `;
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    overlay.remove();
                }
            });
            document.body.appendChild(overlay);
        }

        // Toggle play/pause
        function togglePlay() {
            if (isPlaying) {
                pause();
            } else {
                play();
            }
        }

        // Play
        function play() {
            if (contentItems.length === 0) {
                showNotification('📄 Open a paper first to start reading', 'warning');
                return;
            }
            if (currentIndex >= contentItems.length - 1) {
                currentIndex = 0;
            }

            // Hide the ETA badge once reading begins
            const etaBadge = document.getElementById('etaBadge');
            if (etaBadge) etaBadge.style.display = 'none';

            isPlaying = true;
            playBtn.querySelector('span').textContent = '⏸';
            lastUpdate = performance.now();
            animationFrame = requestAnimationFrame(animate);
            
            if (!readingStartTime) {
                readingStartTime = Date.now();
            }
        }

        // Pause
        function pause() {
            isPlaying = false;
            playBtn.querySelector('span').textContent = '▶';
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            
            if (readingStartTime) {
                const sessionMinutes = (Date.now() - readingStartTime) / 60000;
                dailyGoal.current += sessionMinutes;
                saveGoals();
                readingStartTime = null;
            }
            
            saveCurrentPaperProgress();
        }

        // Animation loop
        function animate(timestamp) {
            if (!isPlaying) return;

            const elapsed = timestamp - lastUpdate;
            const item = contentItems[currentIndex];

            let delay;
            if (item.type === ContentType.PAUSE) {
                delay = item.duration;
            } else {
                delay = (60000 / wpm) * chunkSize;
            }

            if (elapsed >= delay) {
                currentIndex += chunkSize;

                if (currentIndex >= contentItems.length) {
                    currentIndex = contentItems.length - 1;
                    pause();
                    
                    // Mark paper as completed
                    if (currentPaperId) {
                        const paper = library.find(p => p.id === currentPaperId);
                        if (paper && !paper.completed) {
                            paper.completed = true;
                            weeklyGoal.current++;
                            saveGoals();
                            saveLibrary();
                            updateLibraryUI();
                            updateHeaderStats();
                            showNotification('🎉 Paper completed!');
                        }
                    }
                    
                    return;
                }

                updateDisplay();
                updateStats();
                updateMapViewport();
                updateSectionPips();
                updateMinimap();

                // Section-by-section chunk mode boundary check
                if (checkChunkBoundary(currentIndex)) {
                    return; // paused at section boundary
                }

                lastUpdate = timestamp;
            }

            animationFrame = requestAnimationFrame(animate);
        }

        // Update statistics
        function updateStats() {
            const textItems = contentItems.filter(i => i.type === ContentType.TEXT);
            const totalWords = textItems.length;
            const currentWord = Math.min(
                textItems.length,
                contentItems.slice(0, currentIndex + 1).filter(i => i.type === ContentType.TEXT).length
            );

            const progress = totalWords > 0 ? (currentWord / totalWords) * 100 : 0;
            progressText.textContent = `${currentWord} / ${totalWords} words`;
            headerProgressDisplay.textContent = Math.round(progress) + '%';
            progressFill.style.width = progress + '%';

            const wordsLeft = totalWords - currentWord;
            const minutesLeft = wordsLeft / wpm;
            const seconds = Math.round(minutesLeft * 60);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            timeRemaining.textContent = `${mins}:${secs.toString().padStart(2, '0')} remaining`;
        }

        // Update header stats
        function updateHeaderStats() {
            const completedCount = library.filter(p => p.completed).length;
            headerPapersDisplay.textContent = completedCount;
        }

        // ── Feature: Estimated Reading Time ──────────────────────────────────
        function showPaperETA() {
            const etaBadge = document.getElementById('etaBadge');
            const etaBadgeText = document.getElementById('etaBadgeText');
            if (!etaBadge) return;
            const totalWords = contentItems.filter(i => i.type === ContentType.TEXT).length;
            if (totalWords === 0) { etaBadge.style.display = 'none'; return; }
            const mins = Math.round(totalWords / wpm);
            const label = mins < 1 ? '<1 min' : mins === 1 ? '~1 min' : `~${mins} min`;
            etaBadgeText.textContent = `${label} read`;
            etaBadge.style.display = 'inline-flex';
        }

        // ── Feature: Page Minimap ─────────────────────────────────────────────
        let minimapLastPage = -1;

        function initMinimap() {
            const thumbs  = thumbnailCache[currentPaperId];
            const sidebar = document.getElementById('minimapSidebar');
            const dots    = document.getElementById('minimapPageDots');

            console.log(`[Minimap] initMinimap called — paperId=${currentPaperId}, thumbs=${thumbs?.length ?? 'none'}, sidebar=${!!sidebar}`);

            if (!sidebar) return;

            if (!thumbs?.length) {
                sidebar.style.display = 'none';
                console.log('[Minimap] Hidden — no thumbnails for this paper');
                return;
            }

            sidebar.style.display = ''; // show sidebar column
            minimapLastPage = -1;       // force first render
            console.log(`[Minimap] Showing sidebar with ${thumbs.length} pages`);

            // Build page dots
            dots.innerHTML = thumbs.map((_, i) =>
                `<div class="minimap-page-dot" id="mdot${i}" title="Page ${i+1}" onclick="minimapJumpToPage(${i+1})"></div>`
            ).join('');

            updateMinimap();
        }

        function updateMinimap() {
            const thumbs = thumbnailCache[currentPaperId];
            if (!thumbs?.length) return;

            const paper  = library.find(p => p.id === currentPaperId);
            const item   = contentItems[currentIndex];
            const pageNum = item?.page || 1;
            const total   = paper?.numPages || thumbs.length;

            // Update page label
            const label = document.getElementById('minimapPageLabel');
            if (label) label.textContent = `Page ${pageNum} of ${total}`;

            // Update dot highlights
            thumbs.forEach((_, i) => {
                const dot = document.getElementById(`mdot${i}`);
                if (!dot) return;
                dot.classList.toggle('active',  i + 1 === pageNum);
                dot.classList.toggle('visited', i + 1 < pageNum);
            });

            // Only swap image when page actually changes
            if (pageNum !== minimapLastPage) {
                minimapLastPage = pageNum;
                const thumb = thumbs[pageNum - 1];
                const img   = document.getElementById('minimapThumbImg');
                const ph    = document.getElementById('minimapPlaceholder');
                const strip = document.getElementById('minimapStrip');

                if (thumb && img) {
                    img.src = thumb;
                    img.style.display   = 'block';
                    ph.style.display    = 'none';
                    strip.style.display = 'block';
                } else {
                    img.style.display   = 'none';
                    ph.style.display    = 'block';
                    ph.textContent      = `Page ${pageNum}`;
                    strip.style.display = 'none';
                }
            }

            // Update the position strip
            updateMinimapStrip(pageNum);
        }

        function updateMinimapStrip(pageNum) {
            const strip = document.getElementById('minimapStrip');
            if (!strip) return;

            const pageItems = contentItems.filter(it => it.page === pageNum && it.type === ContentType.TEXT);
            const currentWordOnPage = contentItems
                .slice(0, currentIndex + 1)
                .filter(it => it.page === pageNum && it.type === ContentType.TEXT).length;

            const totalOnPage = pageItems.length;
            if (totalOnPage === 0) return;

            const progress = currentWordOnPage / totalOnPage;
            // Map 0–1 to 5%–88% of thumbnail height (leaving margins for page header/footer)
            const topPct = 5 + progress * 83;
            strip.style.top = topPct + '%';
        }

        function minimapJumpToPage(pageNum) {
            const idx = contentItems.findIndex(it => it.page === pageNum);
            if (idx >= 0) {
                pause();
                currentIndex = idx;
                updateDisplay();
                updateStats();
                updateMinimap();
                showNotification(`📄 Jumped to page ${pageNum}`);
            }
        }

        // ── Feature: Section Progress Pips ──────────────────────────────────
        function updateSectionPips() {
            const container = document.getElementById('sectionPips');
            if (!container) return;
            if (!documentSections || documentSections.length < 2) {
                container.innerHTML = ''; return;
            }
            // Build pips
            const totalWords = contentItems.filter(i => i.type === ContentType.TEXT).length;
            const currentWord = contentItems.slice(0, currentIndex + 1).filter(i => i.type === ContentType.TEXT).length;
            let sectionWordCount = 0;
            const html = documentSections.map((sec, i) => {
                sectionWordCount += (sec.words?.length || 0);
                const sectionProgress = totalWords > 0 ? sectionWordCount / totalWords : 0;
                const isCurrent = sectionProgress * totalWords >= currentWord && 
                                  (i === 0 || ((documentSections.slice(0, i).reduce((a,s) => a + (s.words?.length||0), 0) / totalWords) * totalWords < currentWord));
                const isDone = (sectionWordCount / totalWords) * totalWords < currentWord;
                return `<div class="section-pip ${isDone ? 'done' : isCurrent ? 'current' : ''}" title="Section ${i+1}"></div>`;
            }).join('');
            container.innerHTML = html;
        }

        // ── Feature: Section-by-Section Chunk Mode ───────────────────────────
        function checkChunkBoundary(idx) {
            if (!isChunkMode || !documentSections || documentSections.length < 2) return false;
            // Find which section we just completed
            let wordCount = 0;
            for (let i = 0; i < documentSections.length - 1; i++) {
                wordCount += (documentSections[i].words?.length || 0);
                // Map word count to content index approximately
                const sectionEndIndex = contentItems.filter((_,ci) => {
                    return contentItems.slice(0, ci+1).filter(c => c.type === ContentType.TEXT).length <= wordCount;
                }).length;
                if (idx === sectionEndIndex && idx > 0) {
                    // At a section boundary — pause
                    isPlaying = false;
                    const playBtn = document.getElementById('playBtn');
                    if (playBtn) { const sp = playBtn.querySelector('span'); if (sp) sp.textContent = '▶'; }
                    chunkNextSectionStart = idx + 1;
                    const banner = document.getElementById('chunkPauseBanner');
                    const title = document.getElementById('chunkPauseTitle');
                    const sub = document.getElementById('chunkPauseSub');
                    if (banner) {
                        title.textContent = `Section ${i + 1} of ${documentSections.length} complete ✓`;
                        sub.textContent = documentSections[i+1]?.title 
                            ? `Up next: "${documentSections[i+1].title}" — take a breath first.`
                            : 'Take a breath. Ready for the next section?';
                        banner.classList.add('visible');
                    }
                    return true;
                }
            }
            return false;
        }

        function chunkContinue() {
            const banner = document.getElementById('chunkPauseBanner');
            if (banner) banner.classList.remove('visible');
            if (chunkNextSectionStart >= 0) {
                currentIndex = chunkNextSectionStart;
                chunkNextSectionStart = -1;
            }
            play();
        }

        function chunkSkip() {
            const banner = document.getElementById('chunkPauseBanner');
            if (banner) banner.classList.remove('visible');
            isChunkMode = false;
            document.querySelectorAll('[data-chunkmode]').forEach(b => {
                b.classList.toggle('active', b.dataset.chunkmode === 'false');
            });
        }

        // Save current paper progress
        function saveCurrentPaperProgress() {
            if (!currentPaperId) return;

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) return;

            const textItems = contentItems.filter(i => i.type === ContentType.TEXT);
            const totalWords = textItems.length;
            const currentWord = contentItems.slice(0, currentIndex + 1)
                .filter(i => i.type === ContentType.TEXT).length;
            const progress = totalWords > 0 ? (currentWord / totalWords) * 100 : 0;

            paper.currentIndex = currentIndex;
            paper.progress = Math.round(progress);
            saveLibrary();
        }

        // Update paper stats
        function updatePaperStats() {
            if (!currentPaperId) return;

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) return;

            if (readingStartTime) {
                const sessionMinutes = (Date.now() - readingStartTime) / 60000;
                paper.readingTime = (paper.readingTime || 0) + sessionMinutes;
                readingStartTime = null;
            }

            saveLibrary();
        }

        // Add bookmark
        function addBookmark() {
            if (!currentPaperId || contentItems.length === 0) {
                showNotification('⚠️ No paper loaded', 'warning');
                return;
            }

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) return;

            const textItems = contentItems.filter(i => i.type === ContentType.TEXT);
            const currentWord = contentItems.slice(0, currentIndex + 1)
                .filter(i => i.type === ContentType.TEXT).length;
            
            const contextStart = Math.max(0, currentWord - 5);
            const contextEnd = Math.min(textItems.length, currentWord + 10);
            const preview = textItems.slice(contextStart, contextEnd)
                .map(i => i.content)
                .join(' ');

            const bookmark = {
                id: Date.now(),
                index: currentIndex,
                wordPosition: currentWord,
                preview: preview,
                timestamp: new Date().toISOString()
            };

            paper.bookmarks.push(bookmark);
            saveLibrary();
            showNotification('🔖 Bookmark added');
        }

        // Add highlight
        function addHighlight() {
            if (!currentPaperId || contentItems.length === 0) {
                showNotification('⚠️ No paper loaded', 'warning');
                return;
            }

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) return;

            const textItems = contentItems.filter(i => i.type === ContentType.TEXT);
            const currentWord = contentItems.slice(0, currentIndex + 1)
                .filter(i => i.type === ContentType.TEXT).length;
            
            const contextStart = Math.max(0, currentWord - 10);
            const contextEnd = Math.min(textItems.length, currentWord + 10);
            const text = textItems.slice(contextStart, contextEnd)
                .map(i => i.content)
                .join(' ');

            const highlight = {
                id: Date.now(),
                index: currentIndex,
                wordPosition: currentWord,
                text: text,
                timestamp: new Date().toISOString()
            };

            paper.highlights.push(highlight);
            saveLibrary();
            updateHighlightsUI();
            showNotification('✨ Highlight added');
        }

        // Update highlights UI
        function updateHighlightsUI() {
            if (!currentPaperId) return;

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper || paper.highlights.length === 0) {
                highlightsList.innerHTML = `
                    <p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl);">
                        No highlights yet. Press H or click the highlight button while reading to mark important passages.
                    </p>
                `;
                highlightCount.textContent = '(0)';
                return;
            }

            highlightCount.textContent = `(${paper.highlights.length})`;
            highlightsList.innerHTML = paper.highlights.map(h => `
                <div class="highlight-item" data-id="${h.id}">
                    <div class="highlight-text">"${h.text}"</div>
                    <div class="highlight-meta">
                        Position: ${h.wordPosition} • ${new Date(h.timestamp).toLocaleString()}
                    </div>
                </div>
            `).join('');

            // Add click handlers
            document.querySelectorAll('.highlight-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = parseInt(item.dataset.id);
                    const highlight = paper.highlights.find(h => h.id === id);
                    if (highlight) {
                        currentIndex = highlight.index;
                        updateDisplay();
                        updateStats();
                        updateMapViewport();
                        
                        // Switch to read tab
                        document.querySelectorAll('.reader-tab').forEach(t => t.classList.remove('active'));
                        document.querySelector('[data-tab="read"]').classList.add('active');
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-tab-content="read"]').classList.add('active');
                        
                        showNotification('📍 Jumped to highlight');
                    }
                });
            });
        }

        // Update media grid
        function updateMediaGrid() {
            const mediaGrid = document.getElementById('mediaGrid');
            const mediaCountEl = document.getElementById('mediaCount');
            
            if (!currentPaperId) {
                mediaGrid.innerHTML = '<p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl); grid-column: 1 / -1;">No paper selected</p>';
                mediaCountEl.textContent = '(0)';
                return;
            }

            const paper = library.find(p => p.id === currentPaperId);
            const mediaItems = paper?.media || [];

            if (mediaItems.length === 0) {
                mediaGrid.innerHTML = '<p style="text-align: center; color: var(--text-tertiary); padding: var(--space-2xl); grid-column: 1 / -1;">No figures or tables detected in this paper.</p>';
                mediaCountEl.textContent = '(0)';
                return;
            }

            mediaCountEl.textContent = `(${mediaItems.length})`;

            mediaGrid.innerHTML = mediaItems.map((item, index) => {
                const typeLabel = item.type === 'figure' ? `Figure ${item.number}`
                                : item.type === 'table'   ? `Table ${item.number}`
                                : item.type === 'equation' ? `Equation ${item.number}`
                                : `Item ${item.number}`;
                const icon = item.type === 'figure' ? '📊' : item.type === 'table' ? '📋' : '∑';
                const hasImage = item.type === 'figure' && item.image;

                const previewContent = hasImage
                    ? `<img src="${item.image}" alt="${item.caption}" style="max-width:100%;max-height:160px;object-fit:contain;">`
                    : item.imageStripped
                        ? `<div style="font-size:11px;color:var(--text-tertiary);padding:8px;text-align:center;">
                              <div style="font-size:28px;margin-bottom:4px;">🖼️</div>
                              Re-open this paper to view image
                           </div>`
                    : item.type === 'equation'
                        ? `<div style="font-family:monospace;font-size:13px;padding:8px;word-break:break-all;color:var(--text-primary);">${item.latex || item.caption}</div>`
                        : `<div style="font-size:40px;color:var(--text-tertiary);">${icon}</div>`;

                return `
                    <div class="media-item" data-index="${index}">
                        <div class="media-item-preview ${item.type !== 'figure' ? 'table-preview' : ''}" style="min-height:80px;display:flex;align-items:center;justify-content:center;">
                            ${previewContent}
                        </div>
                        <div class="media-item-label">${typeLabel}</div>
                        <div class="media-item-caption">${(item.caption || '').slice(0, 120)}</div>
                        ${item.pageNumber ? `<div style="font-size:10px;color:var(--text-tertiary);margin-top:4px;">Page ${item.pageNumber}</div>` : ''}
                    </div>
                `;
            }).join('');

            // Click handlers to jump to this item in the reader
            document.querySelectorAll('.media-item').forEach(el => {
                el.addEventListener('click', () => {
                    const index = parseInt(el.dataset.index);
                    const mediaItem = mediaItems[index];

                    const mediaIndex = contentItems.findIndex(c =>
                        (c.type === ContentType.FIGURE   && c.number === mediaItem.number && mediaItem.type === 'figure') ||
                        (c.type === ContentType.TABLE     && c.number === mediaItem.number && mediaItem.type === 'table') ||
                        (c.type === 'equation'            && c.number === mediaItem.number && mediaItem.type === 'equation')
                    );

                    if (mediaIndex >= 0) {
                        currentIndex = mediaIndex;
                        updateDisplay(); updateStats(); updateMapViewport();
                        document.querySelectorAll('.reader-tab').forEach(t => t.classList.remove('active'));
                        document.querySelector('[data-tab="read"]').classList.add('active');
                        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                        document.querySelector('[data-tab-content="read"]').classList.add('active');
                        showNotification(`📍 Jumped to ${el.querySelector('.media-item-label').textContent}`);
                    } else {
                        showNotification(`📄 ${el.querySelector('.media-item-label').textContent} on page ${mediaItem.pageNumber || '?'}`);
                    }
                });
            });
        }

        // Save notes
        function saveNotes() {
            if (!currentPaperId) return;

            const paper = library.find(p => p.id === currentPaperId);
            if (!paper) return;

            paper.notes = {
                keyFindings: notesKeyFindings.value,
                summary: notesSummary.value,
                relevance: notesRelevance.value,
                questions: notesQuestions.value
            };

            saveLibrary();
            showNotification('💾 Notes saved');
        }

        // Edit paper
        function editPaper(paperId) {
            const paper = library.find(p => p.id === paperId);
            if (!paper) return;

            const modal = createModal('Edit Paper Metadata', `
                <div class="form-group">
                    <label class="form-label">Title *</label>
                    <input type="text" id="editPaperTitle" value="${paper.title}">
                </div>
                <div class="form-group">
                    <label class="form-label">Authors</label>
                    <input type="text" id="editPaperAuthors" value="${paper.authors || ''}">
                </div>
                <div class="form-group">
                    <label class="form-label">Year</label>
                    <input type="text" id="editPaperYear" value="${paper.year || ''}">
                </div>
                <div class="form-group">
                    <label class="form-label">Journal / Conference</label>
                    <input type="text" id="editPaperJournal" value="${paper.journal || ''}">
                </div>
                <div class="form-group">
                    <label class="form-label">DOI / URL</label>
                    <input type="text" id="editPaperDoi" value="${paper.doi || ''}">
                </div>
                <div class="form-group">
                    <label class="form-label">Tags (comma-separated)</label>
                    <input type="text" id="editPaperTags" value="${paper.tags.join(', ')}">
                </div>
            `, () => {
                const title = document.getElementById('editPaperTitle').value.trim();
                if (!title) {
                    showNotification('⚠️ Title is required', 'warning');
                    return false;
                }

                paper.title = title;
                paper.authors = document.getElementById('editPaperAuthors').value.trim();
                paper.year = document.getElementById('editPaperYear').value.trim();
                paper.journal = document.getElementById('editPaperJournal').value.trim();
                paper.doi = document.getElementById('editPaperDoi').value.trim();
                paper.tags = document.getElementById('editPaperTags').value.split(',').map(t => t.trim()).filter(t => t);

                saveLibrary();
                updateLibraryUI();
                
                if (currentPaperId === paperId) {
                    currentPaperTitle.textContent = paper.title;
                    currentPaperMeta.textContent = [
                        paper.authors,
                        paper.year,
                        paper.journal
                    ].filter(x => x).join(' • ');
                }

                showNotification('✅ Paper updated');
                return true;
            });
        }

        // Export paper
        function exportPaper(paperId) {
            const paper = library.find(p => p.id === paperId);
            if (!paper) return;

            const exportData = {
                metadata: {
                    title: paper.title,
                    authors: paper.authors,
                    year: paper.year,
                    journal: paper.journal,
                    doi: paper.doi,
                    tags: paper.tags
                },
                notes: paper.notes,
                highlights: paper.highlights,
                bookmarks: paper.bookmarks,
                summaries: paper.summaries || [],
                media: paper.media || [],
                stats: {
                    progress: paper.progress,
                    readingTime: Math.round(paper.readingTime || 0),
                    completed: paper.completed
                },
                exportDate: new Date().toISOString()
            };

            const json = JSON.stringify(exportData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${paper.title.replace(/[^a-z0-9]/gi, '-')}-export.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('📥 Paper exported');
        }

        // Duplicate paper
        function duplicatePaper(paperId) {
            const paper = library.find(p => p.id === paperId);
            if (!paper) return;

            const duplicate = {
                ...paper,
                id: Date.now(),
                title: paper.title + ' (Copy)',
                addedDate: new Date().toISOString(),
                progress: 0,
                currentIndex: 0,
                bookmarks: [],
                highlights: [],
                summaries: paper.summaries ? [...paper.summaries] : [],
                media: paper.media ? [...paper.media] : [],
                readingTime: 0,
                completed: false
            };

            library.unshift(duplicate);
            saveLibrary();
            updateLibraryUI();
            showNotification(`📋 Duplicated: ${paper.title}`);
        }

        // Delete paper
        function deletePaper(paperId) {
            library = library.filter(p => p.id !== paperId);
            
            if (currentPaperId === paperId) {
                currentPaperId = null;
                contentItems = [];
                currentIndex = 0;
                readerHeader.style.display = 'none';
                updateDisplay();
                updateStats();
            }

            saveLibrary();
            updateLibraryUI();
            updateHeaderStats();
            showNotification('🗑️ Paper deleted');
        }

        // Detect document sections — robust version for real PDF/DOCX text
        function detectDocumentSections() {
            documentSections = [];
            if (contentItems.length === 0) return;

            const textItems = contentItems.filter(i => i.type === ContentType.TEXT);
            if (textItems.length === 0) return;

            const allWords = textItems.map(i => i.content);
            const fullText = allWords.join(' ');

            // ── Strategy 1: detect named section headings ──────────────────
            const HEADING_RE = /(?:^|\s)((?:(?:\d+\.?\s+)?(?:abstract|introduction|background|related work|literature review|methods?|methodology|materials?\s+and\s+methods?|experimental|results?|findings?|analysis|evaluation|discussion|limitations?|future\s+work|conclusion|conclusions?|references?|bibliography|appendix|acknowledgements?))(?:\s|$))/gi;

            const wordStarts = [];
            let pos = 0;
            for (const word of allWords) {
                while (pos < fullText.length && fullText[pos] === ' ') pos++;
                wordStarts.push(pos);
                pos += word.length;
            }

            function charToWordIdx(charIdx) {
                let lo = 0, hi = wordStarts.length - 1;
                while (lo < hi) {
                    const mid = (lo + hi + 1) >> 1;
                    if (wordStarts[mid] <= charIdx) lo = mid; else hi = mid - 1;
                }
                return lo;
            }

            const headings = [];
            let m;
            HEADING_RE.lastIndex = 0;
            while ((m = HEADING_RE.exec(fullText)) !== null) {
                const wIdx = charToWordIdx(m.index);
                const raw = m[1].trim().replace(/^\d+\.?\s*/, '');
                const title = raw.charAt(0).toUpperCase() + raw.slice(1).toLowerCase();
                if (!headings.find(h => Math.abs(h.wordIndex - wIdx) < 10)) {
                    headings.push({ wordIndex: wIdx, title });
                }
            }
            headings.sort((a, b) => a.wordIndex - b.wordIndex);

            // ── Strategy 2: chunk by word count if no headings found ────────
            const CHUNK_SIZE = 600;
            if (headings.length < 2) {
                const numChunks = Math.ceil(allWords.length / CHUNK_SIZE);
                for (let i = 0; i < numChunks; i++) {
                    const start = i * CHUNK_SIZE;
                    const end = Math.min(start + CHUNK_SIZE - 1, allWords.length - 1);
                    documentSections.push({
                        title: i === 0 ? 'Document (Part 1)' : `Document (Part ${i + 1})`,
                        startIndex: start, endIndex: end,
                        words: allWords.slice(start, end + 1)
                    });
                }
                console.log(`[Sections] No headings — split into ${documentSections.length} chunks`);
                return;
            }

            // ── Build sections from headings ────────────────────────────────
            if (headings[0].wordIndex > 50) {
                documentSections.push({
                    title: 'Preamble', startIndex: 0, endIndex: headings[0].wordIndex - 1,
                    words: allWords.slice(0, headings[0].wordIndex)
                });
            }
            for (let i = 0; i < headings.length; i++) {
                const start = headings[i].wordIndex;
                const end = i + 1 < headings.length ? headings[i + 1].wordIndex - 1 : allWords.length - 1;
                const words = allWords.slice(start, end + 1);
                if (words.length > 0) documentSections.push({ title: headings[i].title, startIndex: start, endIndex: end, words });
            }

            // ── Split any oversized sections ────────────────────────────────
            const expanded = [];
            for (const sec of documentSections) {
                if (sec.words.length <= 1500) { expanded.push(sec); continue; }
                const parts = Math.ceil(sec.words.length / 700);
                for (let p = 0; p < parts; p++) {
                    const s = p * 700, e = Math.min(s + 699, sec.words.length - 1);
                    expanded.push({
                        title: `${sec.title} (${p + 1}/${parts})`,
                        startIndex: sec.startIndex + s, endIndex: sec.startIndex + e,
                        words: sec.words.slice(s, e + 1)
                    });
                }
            }
            documentSections = expanded;

            console.log(`[Sections] ${documentSections.length} sections:`, documentSections.map(s => `"${s.title}" (${s.words.length}w)`));
        }

        // Build document map
        function buildDocumentMap() {
            if (contentItems.length === 0) return;

            detectDocumentSections();
            mapSections.innerHTML = '';

            const mapHeight = mapContainer.clientHeight;
            const totalWords = contentItems.filter(i => i.type === ContentType.TEXT).length;

            documentSections.forEach((section, index) => {
                const sectionDiv = document.createElement('div');
                sectionDiv.className = 'map-section';
                
                const startPercent = (section.startIndex / totalWords) * 100;
                const endPercent = (section.endIndex / totalWords) * 100;
                const height = Math.max(3, ((endPercent - startPercent) / 100) * mapHeight);
                
                sectionDiv.style.top = `${(startPercent / 100) * mapHeight}px`;
                sectionDiv.style.height = `${height}px`;
                sectionDiv.title = section.title;
                
                sectionDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    jumpToSection(index);
                });

                mapSections.appendChild(sectionDiv);
            });

            updateMapViewport();
        }

        // Update map viewport
        function updateMapViewport() {
            // Map disabled - returning early
            return;
        }
        
        /* OLD MAP FUNCTION - DISABLED TO PREVENT ERRORS
        function updateMapViewportOld() {
            const viewportSize = Math.max(20, Math.min(80, (50 / totalItems) * mapHeight));
            const viewportTop = Math.max(0, Math.min(mapHeight - viewportSize, progress * mapHeight));

            mapViewport.style.height = `${viewportSize}px`;
            mapViewport.style.top = `${viewportTop}px`;

            mapProgress.style.width = `${progress * 100}%`;
            mapPosition.textContent = `${Math.round(progress * 100)}%`;

            const textIndex = contentItems.slice(0, currentIndex)
                .filter(i => i.type === ContentType.TEXT).length;
            
            const currentSection = documentSections.find(section => 
                textIndex >= section.startIndex && textIndex <= section.endIndex
            );

            if (currentSection) {
                const sectionIndex = documentSections.indexOf(currentSection);
                mapSectionDisplay.textContent = `${sectionIndex + 1}/${documentSections.length}`;
                
                document.querySelectorAll('.map-section').forEach((el, idx) => {
                    el.classList.toggle('current', idx === sectionIndex);
                });

                // Check if we've entered a new section during reading
                if (isPlaying && sectionIndex !== currentSectionIndex && sectionIndex > 0) {
                    currentSectionIndex = sectionIndex;
                    pause();
                    showSectionSummary(sectionIndex);
                }
            }
        }

        // Viewport dragging
        mapViewport.addEventListener('mousedown', (e) => {
            isDraggingViewport = true;
            dragStartY = e.clientY;
            dragStartTop = parseFloat(mapViewport.style.top || 0);
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (!isDraggingViewport) return;

            const deltaY = e.clientY - dragStartY;
            const mapHeight = mapContainer.clientHeight;
            const viewportHeight = mapViewport.clientHeight;
            
            let newTop = dragStartTop + deltaY;
            newTop = Math.max(0, Math.min(mapHeight - viewportHeight, newTop));
            
            mapViewport.style.top = `${newTop}px`;

            const progress = newTop / (mapHeight - viewportHeight);
            const newIndex = Math.round(progress * (contentItems.length - 1));
            
            const textIndex = contentItems.slice(0, newIndex)
                .filter(i => i.type === ContentType.TEXT).length;
            const totalWords = contentItems.filter(i => i.type === ContentType.TEXT).length;
            mapPosition.textContent = `${Math.round((textIndex / totalWords) * 100)}%`;
        });

        document.addEventListener('mouseup', (e) => {
            if (!isDraggingViewport) return;

            isDraggingViewport = false;

            const mapHeight = mapContainer.clientHeight;
            const viewportHeight = mapViewport.clientHeight;
            const viewportTop = parseFloat(mapViewport.style.top || 0);
            const progress = viewportTop / (mapHeight - viewportHeight);
            
            currentIndex = Math.round(progress * (contentItems.length - 1));
            currentIndex = Math.max(0, Math.min(contentItems.length - 1, currentIndex));
            
            updateDisplay();
            updateStats();
            updateMapViewport();
            saveCurrentPaperProgress();

            showNotification(\`📍 Jumped to \${Math.round(progress * 100)}%\`);
        });
        */ // END OLD MAP FUNCTIONS - ALL DISABLED

        // Jump to section
        function jumpToSection(sectionIndex) {
            if (sectionIndex < 0 || sectionIndex >= documentSections.length) return;

            const section = documentSections[sectionIndex];
            
            let itemIndex = 0;
            let textCount = 0;
            
            for (let i = 0; i < contentItems.length; i++) {
                if (contentItems[i].type === ContentType.TEXT) {
                    if (textCount >= section.startIndex) {
                        itemIndex = i;
                        break;
                    }
                    textCount++;
                }
            }

            currentIndex = itemIndex;
            updateDisplay();
            updateStats();
            updateMapViewport();
            saveCurrentPaperProgress();

            showNotification(`📍 ${section.title}`);
        }

        // Break timer
        function resetBreakTimer() {
            if (breakTimer) {
                clearTimeout(breakTimer);
                breakTimer = null;
            }

            if (breakInterval > 0) {
                breakTimer = setTimeout(showBreakReminder, breakInterval * 60 * 1000);
            }
        }

        function showBreakReminder() {
            pause();

            const reminder = document.createElement('div');
            reminder.className = 'break-reminder';
            reminder.innerHTML = `
                <div class="break-icon">☕</div>
                <div class="break-title">Time for a Break!</div>
                <div class="break-message">
                    You've been reading for ${breakInterval} minutes. Take a short break to rest your eyes and mind.
                </div>
                <div style="display: flex; gap: var(--space-md); justify-content: center;">
                    <button class="button button-primary" id="breakContinue">
                        Continue Reading
                    </button>
                    <button class="button button-secondary" id="breakTake">
                        Take 5 Min Break
                    </button>
                </div>
            `;

            document.body.appendChild(reminder);

            document.getElementById('breakContinue').addEventListener('click', () => {
                reminder.remove();
                resetBreakTimer();
            });

            document.getElementById('breakTake').addEventListener('click', () => {
                reminder.remove();
                showNotification('⏰ Break timer set for 5 minutes');
                setTimeout(() => {
                    showNotification('✅ Break time over! Ready to continue?');
                    resetBreakTimer();
                }, 5 * 60 * 1000);
            });
        }

        // Show goals modal
        function showGoalsModal() {
            const weeklyProgress = weeklyGoal.target > 0 ? (weeklyGoal.current / weeklyGoal.target) * 100 : 0;
            const dailyProgress = dailyGoal.target > 0 ? (dailyGoal.current / dailyGoal.target) * 100 : 0;

            const modal = createModal('Reading Goals', `
                <div class="goals-grid">
                    <div class="goal-card">
                        <div class="goal-header">
                            <div class="goal-title">Weekly Papers Goal</div>
                            <div class="goal-value">${weeklyGoal.current}/${weeklyGoal.target}</div>
                        </div>
                        <div class="goal-progress-bar">
                            <div class="goal-progress-fill" style="width: ${Math.min(100, weeklyProgress)}%"></div>
                        </div>
                        <div class="goal-label">${Math.round(weeklyProgress)}% complete</div>
                    </div>
                    
                    <div class="goal-card">
                        <div class="goal-header">
                            <div class="goal-title">Daily Reading Time</div>
                            <div class="goal-value">${Math.round(dailyGoal.current)}/${dailyGoal.target} min</div>
                        </div>
                        <div class="goal-progress-bar">
                            <div class="goal-progress-fill" style="width: ${Math.min(100, dailyProgress)}%"></div>
                        </div>
                        <div class="goal-label">${Math.round(dailyProgress)}% complete</div>
                    </div>
                </div>
                
                <div style="margin-top: var(--space-lg);">
                    <div class="form-group">
                        <label class="form-label">Weekly Papers Target</label>
                        <input type="number" id="goalWeekly" value="${weeklyGoal.target}" min="1" max="100">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Daily Reading Minutes Target</label>
                        <input type="number" id="goalDaily" value="${dailyGoal.target}" min="1" max="480">
                    </div>
                    <button class="button button-primary" id="resetGoalsBtn" style="width: 100%;">
                        Reset Progress
                    </button>
                </div>
            `, () => {
                weeklyGoal.target = parseInt(document.getElementById('goalWeekly').value) || 10;
                dailyGoal.target = parseInt(document.getElementById('goalDaily').value) || 60;
                saveGoals();
                showNotification('✅ Goals updated');
                return true;
            });

            document.getElementById('resetGoalsBtn').addEventListener('click', () => {
                if (confirm('Reset your weekly and daily progress? This cannot be undone.')) {
                    weeklyGoal.current = 0;
                    dailyGoal.current = 0;
                    saveGoals();
                    showNotification('🔄 Progress reset');
                    document.querySelector('.modal-overlay').remove();
                    showGoalsModal();
                }
            });
        }

        // Show export modal
        function showExportModal() {
            const modal = createModal('Export Data', `
                <div style="margin-bottom: var(--space-lg);">
                    <p style="color: var(--text-secondary); margin-bottom: var(--space-md);">
                        Export your library, reading data, and settings.
                    </p>
                    <div class="button-group" style="display: grid; gap: var(--space-sm);">
                        <button class="button button-primary" id="exportLibraryBtn">
                            📚 Export Library
                        </button>
                        <button class="button button-primary" id="exportCompleteBtn">
                            💾 Export Everything
                        </button>
                        <button class="button button-secondary" id="importDataBtn">
                            📥 Import Data
                        </button>
                    </div>
                </div>
            `);

            document.getElementById('exportLibraryBtn').addEventListener('click', () => {
                exportData(library, 'swifts-library');
                showNotification('📥 Library exported');
            });

            document.getElementById('exportCompleteBtn').addEventListener('click', () => {
                const allData = {
                    library,
                    settings: {
                        wpm,
                        chunkSize,
                        fontSize,
                        fontFamily,
                        highlightMode,
                        isDyslexic,
                        theme,
                        breakInterval
                    },
                    goals: { weekly: weeklyGoal, daily: dailyGoal },
                    streak: { streak: readingStreak, lastDate: lastReadDate },
                    exportDate: new Date().toISOString()
                };
                exportData(allData, 'swifts-complete-backup');
                showNotification('📥 Complete backup exported');
            });

            document.getElementById('importDataBtn').addEventListener('click', () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);

                        if (confirm('Import this data? This will replace your current library and settings.')) {
                            if (data.library) library = data.library;
                            if (data.settings) {
                                Object.assign({ wpm, chunkSize, fontSize, fontFamily, highlightMode, isDyslexic, theme, breakInterval }, data.settings);
                            }
                            if (data.goals) {
                                weeklyGoal = data.goals.weekly || weeklyGoal;
                                dailyGoal = data.goals.daily || dailyGoal;
                            }
                            if (data.streak) {
                                readingStreak = data.streak.streak || 0;
                                lastReadDate = data.streak.lastDate || null;
                            }

                            saveLibrary();
                            saveSettings();
                            saveGoals();
                            updateLibraryUI();
                            updateHeaderStats();
                            updateStreak();

                            showNotification('✅ Data imported successfully');
                            document.querySelector('.modal-overlay').remove();
                        }
                    } catch (error) {
                        console.error('[Import] Error:', error);
                        showNotification('❌ Failed to import data', 'error');
                    }
                };
                input.click();
            });
        }

        // Export data
        function exportData(data, filename) {
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filename}-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Show shortcuts modal
        function showShortcutsModal() {
            const shortcuts = [
                { key: 'Space', desc: 'Play / Pause reading' },
                { key: '←', desc: 'Previous word/chunk' },
                { key: '→', desc: 'Next word/chunk' },
                { key: 'F', desc: 'Toggle Focus Mode' },
                { key: 'B', desc: 'Add Bookmark' },
                { key: 'H', desc: 'Add Highlight' },
                { key: 'R', desc: 'Restart from beginning' }
            ];

            const shortcutsHTML = `
                <div style="display: grid; gap: var(--space-sm);">
                    ${shortcuts.map(s => `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: var(--space-sm); background: var(--bg-secondary); border-radius: var(--radius-sm);">
                            <span style="font-size: 12px; color: var(--text-secondary);">${s.desc}</span>
                            <span style="font-family: 'SFMono-Regular', 'SF Mono', Consolas, 'Courier New', monospace; font-size: 12px; font-weight: 600; color: var(--primary); background: var(--bg-surface); padding: 2px 8px; border-radius: var(--radius-sm); border: 1px solid var(--border-light);">${s.key}</span>
                        </div>
                    `).join('')}
                </div>
            `;

            createModal('Keyboard Shortcuts', shortcutsHTML);
        }

        // Create modal
        function createModal(title, content, onSave = null) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay';
            
            overlay.innerHTML = `
                <div class="modal">
                    <div class="modal-header">
                        <h2 class="modal-title">${title}</h2>
                        <button class="modal-close">×</button>
                    </div>
                    <div class="modal-content">
                        ${content}
                    </div>
                    ${onSave ? `
                        <div class="modal-footer">
                            <button class="button button-secondary modal-cancel-btn">Cancel</button>
                            <button class="button button-primary modal-save-btn">Save</button>
                        </div>
                    ` : `
                        <div class="modal-footer">
                            <button class="button button-secondary modal-close-btn">Close</button>
                        </div>
                    `}
                </div>
            `;

            document.body.appendChild(overlay);

            const closeModal = () => {
                overlay.remove();
            };

            overlay.querySelector('.modal-close').addEventListener('click', closeModal);
            
            if (onSave) {
                overlay.querySelector('.modal-cancel-btn').addEventListener('click', closeModal);
                overlay.querySelector('.modal-save-btn').addEventListener('click', () => {
                    if (onSave() !== false) {
                        closeModal();
                    }
                });
            } else {
                overlay.querySelector('.modal-close-btn').addEventListener('click', closeModal);
            }

            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) closeModal();
            });

            return overlay;
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            
            const icons = {
                info: 'ℹ️',
                success: '✅',
                warning: '⚠️',
                error: '❌'
            };

            notification.innerHTML = `
                <span class="notification-icon">${icons[type] || icons.info}</span>
                <span>${message}</span>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Debug function - accessible from console
        window.swiftsDebug = function() {
            console.log('=== SWIFTS DEBUG INFO ===');
            console.log('Current Paper ID:', currentPaperId);
            if (currentPaperId) {
                const paper = library.find(p => p.id === currentPaperId);
                if (paper) {
                    console.log('Paper Title:', paper.title);
                    console.log('Sections:', documentSections.length);
                    console.log('Summaries:', paper.summaries?.length || 0);
                    console.log('Media Items:', paper.media?.length || 0);
                    if (paper.media && paper.media.length > 0) {
                        console.log('Media Details:');
                        paper.media.forEach((m, i) => {
                            console.log(`  [${i}] ${m.type.toUpperCase()} ${m.number}:`);
                            console.log(`      Caption: ${m.caption}`);
                            console.log(`      Has Image: ${m.image ? 'YES (' + m.image.substring(0, 50) + '...)' : 'NO'}`);
                            if (m.pageNumber) console.log(`      Page: ${m.pageNumber}`);
                        });
                    }
                    if (paper.summaries && paper.summaries.length > 0) {
                        console.log('Summaries:');
                        paper.summaries.forEach((s, i) => {
                            console.log(`  [${i}] Section ${s.sectionIndex}: ${s.sectionTitle}`);
                            console.log(`      ${s.overview.substring(0, 100)}...`);
                        });
                    }
                    console.log('Content Items:', contentItems.length);
                    console.log('Figures in content:', contentItems.filter(c => c.type === ContentType.FIGURE).length);
                    console.log('Tables in content:', contentItems.filter(c => c.type === ContentType.TABLE).length);
                }
            }
            console.log('Total Library Papers:', library.length);
            console.log('========================');
            console.log('💡 AI-powered section summaries are automatically generated as you read');
            console.log('   Or click "Generate All Summaries" in the Summaries tab');
        };
        console.log('💡 Type swiftsDebug() in console to see detection info');

        // ============================================
        // AUDIO READER — Smart Human Voice Selection
        // ============================================
        // ── TTS word highlight helper ────────────────────────────────────────────
        // Called on each word boundary event during TTS playback.
        // Highlights the spoken word in a dedicated overlay bar beneath the reader.
        let _ttsHighlightBar = null;

        function highlightCurrentWord(word, charPos) {
            if (!word || !isDyslexic || !ttsWordHighlight) return;

            // Create the highlight bar if it doesn't exist
            if (!_ttsHighlightBar) {
                _ttsHighlightBar = document.createElement('div');
                _ttsHighlightBar.id = 'ttsWordBar';
                _ttsHighlightBar.style.cssText = [
                    'position:fixed',
                    'bottom:80px',
                    'left:50%',
                    'transform:translateX(-50%)',
                    'background:var(--primary)',
                    'color:#fff',
                    'padding:8px 24px',
                    'border-radius:24px',
                    'font-size:20px',
                    'font-weight:700',
                    'letter-spacing:3px',
                    'pointer-events:none',
                    'z-index:9999',
                    'opacity:0',
                    'transition:opacity 0.1s',
                    'max-width:80vw',
                    'text-align:center',
                ].join(';');
                document.body.appendChild(_ttsHighlightBar);
            }

            _ttsHighlightBar.textContent = word;
            _ttsHighlightBar.style.opacity = '1';

            // Also highlight matching word spans in the speed-reader display
            document.querySelectorAll('.word-display .word').forEach(span => {
                const matches = span.textContent.trim().toLowerCase().startsWith(word.toLowerCase().slice(0, 4));
                span.style.background    = matches ? 'var(--primary)' : '';
                span.style.color         = matches ? '#fff' : '';
                span.style.borderRadius  = matches ? '4px' : '';
                span.style.padding       = matches ? '0 2px' : '';
            });
        }

        function clearWordHighlight() {
            if (_ttsHighlightBar) _ttsHighlightBar.style.opacity = '0';
            document.querySelectorAll('.word-display .word').forEach(span => {
                span.style.background   = '';
                span.style.color        = '';
                span.style.borderRadius = '';
                span.style.padding      = '';
            });
        }

        // ── Audio / TTS system (browser speechSynthesis) ──────────────────────
        // Picks the highest-quality voice available in the current browser:
        //   Chrome  → Google UK/US voices (neural quality)
        //   Edge    → Microsoft Natural voices (best available anywhere)
        //   Safari  → Siri/Samantha (very natural on Mac/iOS)
        //   Firefox → OS voices (varies by platform)

        let isAudioPlaying  = false;
        let audioFullText   = '';
        let audioCharOffset = 0;
        let audioSpeed      = 1.0;
        let audioSpeeds     = [0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0];
        let currentSpeedIndex = 2;
        let selectedVoice   = null;
        let availableVoices = [];

        const synth = 'speechSynthesis' in window ? window.speechSynthesis : null;

        // ── Voice quality scores ────────────────────────────────────────────
        // Ranked by how natural they sound. Higher = better.
        const VOICE_SCORES = [
            // Microsoft Neural (Edge / Windows) — best browser voices available
            { match: 'aria online (natural)',    score: 100 },
            { match: 'jenny online (natural)',   score: 99  },
            { match: 'natasha online (natural)', score: 98  },
            { match: 'libby online (natural)',   score: 97  },
            { match: 'ryan online (natural)',    score: 96  },
            { match: 'guy online (natural)',     score: 95  },
            { match: 'sonia online (natural)',   score: 94  },
            { match: '(natural)',                score: 90  }, // catch any other MS Natural
            // Google Neural (Chrome)
            { match: 'google uk english female', score: 88 },
            { match: 'google uk english male',   score: 85 },
            { match: 'google us english',        score: 82 },
            { match: 'google',                   score: 75 }, // other Google voices
            // Apple / macOS / iOS
            { match: 'samantha',  score: 80 },
            { match: 'karen',     score: 78 },
            { match: 'daniel',    score: 76 }, // UK English on Mac
            { match: 'moira',     score: 74 },
            { match: 'tessa',     score: 72 },
            { match: 'kate',      score: 70 },
            // Windows built-in
            { match: 'zira',  score: 55 },
            { match: 'david', score: 50 },
        ];

        function scoreVoice(voice) {
            const name = voice.name.toLowerCase();
            for (const { match, score } of VOICE_SCORES) {
                if (name.includes(match)) return score;
            }
            // Online/remote voices tend to be higher quality than local
            if (!voice.localService) return 45;
            return 30;
        }

        function getBestVoice() {
            const en = availableVoices.filter(v => v.lang.startsWith('en'));
            if (!en.length) return availableVoices[0] || null;
            return en.sort((a, b) => scoreVoice(b) - scoreVoice(a))[0];
        }

        function loadVoices() {
            availableVoices = synth ? synth.getVoices() : [];
            if (!availableVoices.length) return;

            // Auto-select best voice on first load
            if (!selectedVoice) {
                selectedVoice = getBestVoice();
                console.log('[Audio] Best voice selected:', selectedVoice?.name,
                            '(score:', scoreVoice(selectedVoice), ')');
            }

            // Populate dropdown
            const sel = document.getElementById('voiceSelector');
            if (!sel) return;

            const en = availableVoices
                .filter(v => v.lang.startsWith('en'))
                .sort((a, b) => scoreVoice(b) - scoreVoice(a));

            sel.innerHTML = en.map(v => {
                const s = scoreVoice(v);
                const tag = s >= 90 ? ' ⭐ Neural' : s >= 75 ? ' ✓ Enhanced' : s >= 50 ? ' · Standard' : '';
                return `<option value="${v.name}" ${selectedVoice?.name === v.name ? 'selected' : ''}>${v.name}${tag}</option>`;
            }).join('');
        }

        // Load voices — Chrome fires onvoiceschanged, Safari fires synchronously
        if (synth) {
            if (synth.onvoiceschanged !== undefined) synth.onvoiceschanged = loadVoices;
            setTimeout(loadVoices, 200);
        }

        // ── Speak from char offset, in chunks to avoid browser 15s cutoff bug ──
        const SPEAK_CHUNK = 2500; // chars per utterance

        function speakFrom(charOffset) {
            if (!synth) return;
            synth.cancel();

            const slice = audioFullText.slice(charOffset, charOffset + SPEAK_CHUNK);
            if (!slice.trim()) { stopAudio(); return; }

            const utter = new SpeechSynthesisUtterance(slice);
            utter.voice = selectedVoice;
            utter.rate  = audioSpeed;
            utter.pitch = 1.0;
            utter.lang  = selectedVoice?.lang || 'en-US';

            // Track position and highlight current word during TTS
            utter.onboundary = e => {
                if (e.name === 'word') {
                    audioCharOffset = charOffset + e.charIndex;

                    // Word highlight — only when dyslexia mode is on with highlight enabled
                    if (isDyslexic && ttsWordHighlight) {
                        // Find the word being spoken in the visible reader display
                        const charPos = charOffset + e.charIndex;
                        // Get text up to current position to find the word
                        const wordText = audioFullText.slice(charPos, charPos + (e.charLength || 20)).split(/\s/)[0];
                        highlightCurrentWord(wordText, charPos);
                    }
                }
            };

            utter.onend = () => {
                const next = charOffset + slice.length;
                if (isAudioPlaying && next < audioFullText.length) {
                    speakFrom(next);
                } else {
                    stopAudio();
                }
            };

            utter.onerror = e => {
                if (e.error !== 'interrupted') {
                    console.error('[Audio] TTS error:', e.error);
                    stopAudio();
                }
            };

            synth.speak(utter);

            // Chrome bug: speechSynthesis pauses after ~15s in background tabs
            // Workaround: pause/resume every 10s to keep it alive
            clearInterval(window._ttsKeepAlive);
            window._ttsKeepAlive = setInterval(() => {
                if (synth.speaking && isAudioPlaying) {
                    synth.pause();
                    synth.resume();
                }
            }, 10000);
        }

        function stopAudio() {
            isAudioPlaying = false;
            clearInterval(window._ttsKeepAlive);
            if (synth) synth.cancel();
            clearWordHighlight();
            const btn = document.getElementById('audioPlayBtn');
            if (btn) btn.textContent = '▶️';
            const pauseBtn = document.getElementById('audioPauseBtn');
            if (pauseBtn) pauseBtn.style.display = 'none';
        }

        function toggleTTSPlay() {
            if (!synth) {
                showNotification('❌ Text-to-speech not supported in this browser', 'error');
                return;
            }
            if (isAudioPlaying) {
                stopAudio();
            } else {
                // Get text from the currently open paper
                const paper = currentPaperId ? library.find(p => p.id === currentPaperId) : null;
                const text = (paper?.text || '').trim();
                if (!text) {
                    showNotification('📄 Open a paper first to use audio reading', 'warning');
                    return;
                }
                audioFullText   = text;
                audioCharOffset = 0;
                isAudioPlaying  = true;
                // Update the audio play button icon
                const btn = document.getElementById('audioPlayBtn');
                if (btn) btn.textContent = '⏸️';
                const pauseBtn = document.getElementById('audioPauseBtn');
                if (pauseBtn) pauseBtn.style.display = '';
                speakFrom(0);
            }
        }

        // ── Voice selector UI ───────────────────────────────────────────────
        function buildVoiceSelectorUI() {
            const audioControls = document.getElementById('audioControls');
            if (!audioControls || document.getElementById('voiceSelector')) return;

            const wrapper = document.createElement('div');
            wrapper.style.cssText = 'display:flex;align-items:center;gap:6px;margin-left:4px;';
            wrapper.innerHTML = `
                <select id="voiceSelector" title="Choose voice"
                    style="font-size:11px;border:1px solid var(--border-light);border-radius:6px;
                           padding:3px 6px;background:var(--bg-surface);color:var(--text-primary);
                           cursor:pointer;max-width:190px;height:28px;">
                    <option>Loading voices…</option>
                </select>`;
            audioControls.appendChild(wrapper);

            wrapper.querySelector('#voiceSelector').addEventListener('change', e => {
                selectedVoice = availableVoices.find(v => v.name === e.target.value) || null;
                console.log('[Audio] Voice changed to:', selectedVoice?.name);
                showNotification('🎤 Voice: ' + (selectedVoice?.name || 'default'));
                if (isAudioPlaying) { stopAudio(); toggleTTSPlay(); }
            });

            loadVoices();
        }

        // ── Init ────────────────────────────────────────────────────────────
        function initAudioControls() {
            const audioPlayBtn = document.getElementById('audioPlayBtn');
            const speedBtn     = document.getElementById('speedBtn');

            // Wire TTS audio buttons
            if (audioPlayBtn) audioPlayBtn.addEventListener('click', toggleTTSPlay);

            const audioPauseBtn = document.getElementById('audioPauseBtn');
            if (audioPauseBtn) audioPauseBtn.addEventListener('click', () => {
                if (synth && synth.speaking) {
                    synth.pause();
                    isAudioPlaying = false;
                    audioPlayBtn.textContent = '▶️';
                    audioPauseBtn.style.display = 'none';
                }
            });

            const audioStopBtn = document.getElementById('audioStopBtn');
            if (audioStopBtn) audioStopBtn.addEventListener('click', () => {
                stopAudio();
                audioCharOffset = 0; // reset position
            });

            // Wire speed control (id="audioSpeed" not "speedBtn")
            const audioSpeedEl = document.getElementById('audioSpeed');
            if (audioSpeedEl) audioSpeedEl.addEventListener('click', () => {
                currentSpeedIndex = (currentSpeedIndex + 1) % audioSpeeds.length;
                audioSpeed = audioSpeeds[currentSpeedIndex];
                audioSpeedEl.textContent = audioSpeed + 'x';
                showNotification('⚡ Speed: ' + audioSpeed + 'x');
                if (isAudioPlaying) { stopAudio(); toggleTTSPlay(); }
            });

            if (speedBtn) speedBtn.addEventListener('click', () => {
                currentSpeedIndex = (currentSpeedIndex + 1) % audioSpeeds.length;
                audioSpeed = audioSpeeds[currentSpeedIndex];
                speedBtn.textContent = audioSpeed + 'x';
                showNotification('⚡ Speed: ' + audioSpeed + 'x');
                if (isAudioPlaying) { stopAudio(); toggleTTSPlay(); }
            });

            buildVoiceSelectorUI();
        }

        document.addEventListener('DOMContentLoaded', () => setTimeout(initAudioControls, 600));
        console.log('🎤 Audio TTS v4 — smart browser voice selection active');
        console.log('💡 Best voices: Google UK English Female (Chrome), Microsoft Neural (Edge), Karen/Moira (Safari)');

    </script>

    <!-- Contact Us Modal -->
    <div id="contactModalOverlay" class="contact-modal-overlay" role="dialog" aria-modal="true" aria-labelledby="appContactModalTitle">
        <div class="contact-modal">
            <button class="contact-modal-close-btn" onclick="closeContactModal()" aria-label="Close contact form">✕</button>
            <div id="appContactForm">
                <h2 id="appContactModalTitle">Contact Us</h2>
                <p class="contact-sub">Have a question or feedback? We'd love to hear from you.</p>
                <form id="appContactFormEl">
                    <div class="contact-field">
                        <label for="appContactEmail">Your Email</label>
                        <input type="email" id="appContactEmail" name="email" placeholder="you@example.com" required>
                    </div>
                    <div class="contact-field">
                        <label for="appContactMessage">Message</label>
                        <textarea id="appContactMessage" name="message" placeholder="Tell us how we can help…" required></textarea>
                    </div>
                    <button type="submit" id="appContactSubmitBtn" class="contact-submit-btn">Send Message</button>
                </form>
            </div>
            <div id="appContactSuccess" class="contact-modal-success">
                <div class="success-icon">✅</div>
                <h3>Message Sent!</h3>
                <p>Thanks for reaching out. We'll get back to you as soon as possible.</p>
            </div>
        </div>
    </div>
    <script>
        /* ── Contact Us Modal ── placed after modal HTML so elements exist immediately ── */
        function openContactModal() {
            document.getElementById('contactModalOverlay').classList.add('open');
            document.getElementById('appContactEmail').focus();
        }
        function closeContactModal() {
            document.getElementById('contactModalOverlay').classList.remove('open');
            document.getElementById('appContactFormEl').reset();
            document.getElementById('appContactForm').style.display = '';
            document.getElementById('appContactSuccess').style.display = 'none';
            const btn = document.getElementById('appContactSubmitBtn');
            if (btn) { btn.disabled = false; btn.textContent = 'Send Message'; }
        }
        // Elements exist now — attach listeners directly (no event wrapper needed)
        document.getElementById('contactModalOverlay').addEventListener('click', function(e) {
            if (e.target === this) closeContactModal();
        });
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && document.getElementById('contactModalOverlay').classList.contains('open')) {
                closeContactModal();
            }
        });
        document.getElementById('appContactFormEl').addEventListener('submit', async function(e) {
            e.preventDefault();
            const btn = document.getElementById('appContactSubmitBtn');
            btn.disabled = true;
            btn.textContent = 'Sending…';
            try {
                const resp = await fetch('https://formspree.io/f/xaqdyvjn', {
                    method: 'POST',
                    headers: { 'Accept': 'application/json' },
                    body: new FormData(this)
                });
                if (resp.ok) {
                    document.getElementById('appContactForm').style.display = 'none';
                    document.getElementById('appContactSuccess').style.display = 'block';
                } else {
                    btn.disabled = false;
                    btn.textContent = 'Send Message';
                    alert('Something went wrong. Please try again.');
                }
            } catch {
                btn.disabled = false;
                btn.textContent = 'Send Message';
                alert('Network error. Please try again.');
            }
        });
    </script>
</body>
</html>
